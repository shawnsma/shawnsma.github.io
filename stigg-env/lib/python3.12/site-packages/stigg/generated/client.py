# Generated by ariadne-codegen
# Source: operations.graphql

from typing import Any, Dict, List, Optional, Union

from .apply_subscription import ApplySubscription
from .archive_customer import ArchiveCustomer
from .base_client import BaseClient
from .base_model import UNSET, UnsetType
from .cancel_subscription import CancelSubscription
from .cancel_subscription_updates import CancelSubscriptionUpdates
from .create_subscription import CreateSubscription
from .delegate_subscription_to_customer import DelegateSubscriptionToCustomer
from .detach_customer_payment_method import DetachCustomerPaymentMethod
from .estimate_subscription import EstimateSubscription
from .estimate_subscription_update import EstimateSubscriptionUpdate
from .get_active_subscriptions import GetActiveSubscriptions
from .get_active_subscriptions_list import GetActiveSubscriptionsList
from .get_checkout_state import GetCheckoutState
from .get_coupons import GetCoupons
from .get_customer_by_id import GetCustomerById
from .get_customer_portal_by_ref_id import GetCustomerPortalByRefId
from .get_customer_statistics import GetCustomerStatistics
from .get_entitlement import GetEntitlement
from .get_entitlements import GetEntitlements
from .get_mock_paywall import GetMockPaywall
from .get_paywall import GetPaywall
from .get_products import GetProducts
from .get_sdk_configuration import GetSdkConfiguration
from .get_subscription import GetSubscription
from .get_subscriptions import GetSubscriptions
from .get_usage_history import GetUsageHistory
from .get_usage_history_v_2 import GetUsageHistoryV2
from .grant_promotional_entitlements import GrantPromotionalEntitlements
from .import_customer import ImportCustomer
from .import_customer_bulk import ImportCustomerBulk
from .import_subscriptions_bulk import ImportSubscriptionsBulk
from .input_types import (
    ApplySubscriptionInput,
    ArchiveCustomerInput,
    CheckoutStateInput,
    CursorPaging,
    CustomerPortalInput,
    DelegateSubscriptionToCustomerInput,
    DetachCustomerPaymentMethodInput,
    EntitlementCheckRequested,
    EstimateSubscriptionInput,
    EstimateSubscriptionUpdateInput,
    FetchEntitlementQuery,
    FetchEntitlementsQuery,
    GetActiveSubscriptionsInput,
    GetCustomerByRefIdInput,
    GetPaywallInput,
    GetSubscriptionInput,
    GrantPromotionalEntitlementsInput,
    ImportCustomerBulkInput,
    ImportCustomerInput,
    ImportSubscriptionsBulkInput,
    PreviewNextInvoiceInput,
    PreviewSubscriptionInput,
    ProvisionCustomerInput,
    ProvisionSubscriptionInput,
    ReportUsageBulkInput,
    ReportUsageInput,
    RevokePromotionalEntitlementInput,
    SubscriptionCancellationInput,
    SubscriptionInput,
    SubscriptionMigrationInput,
    SubscriptionQueryFilter,
    SubscriptionQuerySort,
    SubscriptionUpdateScheduleCancellationInput,
    TransferSubscriptionInput,
    TransferSubscriptionToResourceInput,
    UnarchiveCustomerInput,
    UpdateCustomerInput,
    UpdateSubscriptionInput,
    UsageEventsReportInput,
    UsageHistoryInput,
    UsageHistoryV2Input,
)
from .migrate_subscription_to_latest import MigrateSubscriptionToLatest
from .preview_next_invoice import PreviewNextInvoice
from .preview_subscription import PreviewSubscription
from .provision_customer import ProvisionCustomer
from .provision_subscription import ProvisionSubscription
from .report_entitlement_check_requested import ReportEntitlementCheckRequested
from .report_event import ReportEvent
from .report_usage import ReportUsage
from .report_usage_bulk import ReportUsageBulk
from .revoke_promotional_entitlement import RevokePromotionalEntitlement
from .transfer_subscription import TransferSubscription
from .transfer_subscription_to_resource import TransferSubscriptionToResource
from .unarchive_customer import UnarchiveCustomer
from .update_customer import UpdateCustomer
from .update_subscription import UpdateSubscription


def gql(q: str) -> str:
    return q


class Client(BaseClient):
    def provision_customer(
        self, input: ProvisionCustomerInput, **kwargs: Any
    ) -> ProvisionCustomer:
        query = gql(
            """
            mutation ProvisionCustomer($input: ProvisionCustomerInput!) {
              provisionCustomer(input: $input) {
                ...ProvisionCustomerFragment
              }
            }

            fragment CustomerResourceFragment on CustomerResource {
              resourceId
            }

            fragment EntitlementFragment on Entitlement {
              __typename
              isGranted
              accessDeniedReason
              customerId
              resourceId
              usageLimit
              hasUnlimitedUsage
              hasSoftLimit
              currentUsage
              requestedUsage
              requestedValues
              enumValues
              entitlementUpdatedAt
              usageUpdatedAt
              usagePeriodAnchor
              usagePeriodStart
              usagePeriodEnd
              nextResetDate
              resetPeriod
              resetPeriodConfiguration {
                ...ResetPeriodConfigurationFragment
              }
              feature {
                ...FeatureFragment
              }
            }

            fragment FeatureFragment on EntitlementFeature {
              __typename
              featureType
              meterType
              featureUnits
              featureUnitsPlural
              description
              displayName
              refId
              unitTransformation {
                divide
                round
              }
            }

            fragment PriceFragment on Price {
              billingModel
              billingPeriod
              billingCadence
              billingId
              minUnitQuantity
              maxUnitQuantity
              billingCountryCode
              price {
                amount
                currency
              }
              creditRate {
                amount
                customCurrencyId
              }
              tiersMode
              tiers {
                ...PriceTierFragment
              }
              feature {
                refId
                featureUnits
                featureUnitsPlural
                displayName
                description
              }
              blockSize
            }

            fragment PriceTierFragment on PriceTier {
              upTo
              unitPrice {
                amount
                currency
              }
              flatPrice {
                amount
                currency
              }
            }

            fragment ProvisionCustomerFragment on ProvisionedCustomer {
              customer {
                ...SlimCustomerFragment
              }
              subscriptionDecisionStrategy
              subscription {
                ...SlimSubscriptionFragment
              }
              entitlements {
                ...EntitlementFragment
              }
            }

            fragment ResetPeriodConfigurationFragment on ResetPeriodConfiguration {
              __typename
              ... on YearlyResetPeriodConfig {
                yearlyAccordingTo
              }
              ... on MonthlyResetPeriodConfig {
                monthlyAccordingTo
              }
              ... on WeeklyResetPeriodConfig {
                weeklyAccordingTo
              }
            }

            fragment SlimCustomerFragment on Customer {
              id
              name
              email
              createdAt
              updatedAt
              refId
              customerId
              billingId
              additionalMetaData
              awsMarketplaceCustomerId
            }

            fragment SlimSubscriptionFragment on CustomerSubscription {
              id
              subscriptionId
              refId
              status
              additionalMetaData
              billingId
              billingLinkUrl
              effectiveEndDate
              cancellationDate
              currentBillingPeriodEnd
              pricingType
              latestInvoice {
                ...SubscriptionInvoiceFragment
              }
              paymentCollection
              billingSyncError
              resource {
                ...CustomerResourceFragment
              }
              experimentInfo {
                name
                id
                groupType
                groupName
              }
              prices {
                usageLimit
                price {
                  ...PriceFragment
                }
              }
              totalPrice {
                ...TotalPriceFragment
              }
              plan {
                id
                refId
              }
              addons {
                quantity
                addon {
                  id
                  refId
                }
              }
              customer {
                id
                refId
              }
            }

            fragment SubscriptionInvoiceFragment on SubscriptionInvoice {
              billingId
              status
              createdAt
              dueDate
              updatedAt
              errorMessage
              requiresAction
              paymentSecret
              paymentUrl
              pdfUrl
              billingReason
              currency
              subTotal
              subTotalExcludingTax
              total
              totalExcludingTax
              tax
              amountDue
              attemptCount
            }

            fragment TotalPriceFragment on CustomerSubscriptionTotalPrice {
              subTotal {
                amount
                currency
              }
              total {
                amount
                currency
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="ProvisionCustomer",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return ProvisionCustomer.model_validate(data)

    def import_customer_bulk(
        self, input: ImportCustomerBulkInput, **kwargs: Any
    ) -> ImportCustomerBulk:
        query = gql(
            """
            mutation ImportCustomerBulk($input: ImportCustomerBulkInput!) {
              importCustomersBulk(input: $input)
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="ImportCustomerBulk",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return ImportCustomerBulk.model_validate(data)

    def import_customer(
        self, input: ImportCustomerInput, **kwargs: Any
    ) -> ImportCustomer:
        query = gql(
            """
            mutation ImportCustomer($input: ImportCustomerInput!) {
              importCustomer: importOneCustomer(input: $input) {
                ...SlimCustomerFragment
              }
            }

            fragment SlimCustomerFragment on Customer {
              id
              name
              email
              createdAt
              updatedAt
              refId
              customerId
              billingId
              additionalMetaData
              awsMarketplaceCustomerId
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query, operation_name="ImportCustomer", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return ImportCustomer.model_validate(data)

    def update_customer(
        self, input: UpdateCustomerInput, **kwargs: Any
    ) -> UpdateCustomer:
        query = gql(
            """
            mutation UpdateCustomer($input: UpdateCustomerInput!) {
              updateCustomer: updateOneCustomer(input: $input) {
                ...SlimCustomerFragment
              }
            }

            fragment SlimCustomerFragment on Customer {
              id
              name
              email
              createdAt
              updatedAt
              refId
              customerId
              billingId
              additionalMetaData
              awsMarketplaceCustomerId
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query, operation_name="UpdateCustomer", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return UpdateCustomer.model_validate(data)

    def detach_customer_payment_method(
        self, input: DetachCustomerPaymentMethodInput, **kwargs: Any
    ) -> DetachCustomerPaymentMethod:
        query = gql(
            """
            mutation DetachCustomerPaymentMethod($input: DetachCustomerPaymentMethodInput!) {
              detachCustomerPaymentMethod(input: $input) {
                ...SlimCustomerFragment
              }
            }

            fragment SlimCustomerFragment on Customer {
              id
              name
              email
              createdAt
              updatedAt
              refId
              customerId
              billingId
              additionalMetaData
              awsMarketplaceCustomerId
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="DetachCustomerPaymentMethod",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DetachCustomerPaymentMethod.model_validate(data)

    def grant_promotional_entitlements(
        self, input: GrantPromotionalEntitlementsInput, **kwargs: Any
    ) -> GrantPromotionalEntitlements:
        query = gql(
            """
            mutation GrantPromotionalEntitlements($input: GrantPromotionalEntitlementsInput!) {
              grantPromotionalEntitlements(input: $input) {
                ...PromotionalEntitlementFragment
              }
            }

            fragment PromotionalEntitlementFragment on PromotionalEntitlement {
              status
              usageLimit
              featureId
              hasUnlimitedUsage
              hasSoftLimit
              resetPeriod
              endDate
              isVisible
              feature {
                featureType
                meterType
                featureUnits
                featureUnitsPlural
                displayName
                description
                refId
                additionalMetaData
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="GrantPromotionalEntitlements",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GrantPromotionalEntitlements.model_validate(data)

    def revoke_promotional_entitlement(
        self, input: RevokePromotionalEntitlementInput, **kwargs: Any
    ) -> RevokePromotionalEntitlement:
        query = gql(
            """
            mutation RevokePromotionalEntitlement($input: RevokePromotionalEntitlementInput!) {
              revokePromotionalEntitlement(input: $input) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="RevokePromotionalEntitlement",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return RevokePromotionalEntitlement.model_validate(data)

    def provision_subscription(
        self, input: ProvisionSubscriptionInput, **kwargs: Any
    ) -> ProvisionSubscription:
        query = gql(
            """
            mutation ProvisionSubscription($input: ProvisionSubscriptionInput!) {
              provisionSubscription: provisionSubscriptionV2(input: $input) {
                ...ProvisionSubscriptionFragment
              }
            }

            fragment CustomerResourceFragment on CustomerResource {
              resourceId
            }

            fragment EntitlementFragment on Entitlement {
              __typename
              isGranted
              accessDeniedReason
              customerId
              resourceId
              usageLimit
              hasUnlimitedUsage
              hasSoftLimit
              currentUsage
              requestedUsage
              requestedValues
              enumValues
              entitlementUpdatedAt
              usageUpdatedAt
              usagePeriodAnchor
              usagePeriodStart
              usagePeriodEnd
              nextResetDate
              resetPeriod
              resetPeriodConfiguration {
                ...ResetPeriodConfigurationFragment
              }
              feature {
                ...FeatureFragment
              }
            }

            fragment FeatureFragment on EntitlementFeature {
              __typename
              featureType
              meterType
              featureUnits
              featureUnitsPlural
              description
              displayName
              refId
              unitTransformation {
                divide
                round
              }
            }

            fragment PriceFragment on Price {
              billingModel
              billingPeriod
              billingCadence
              billingId
              minUnitQuantity
              maxUnitQuantity
              billingCountryCode
              price {
                amount
                currency
              }
              creditRate {
                amount
                customCurrencyId
              }
              tiersMode
              tiers {
                ...PriceTierFragment
              }
              feature {
                refId
                featureUnits
                featureUnitsPlural
                displayName
                description
              }
              blockSize
            }

            fragment PriceTierFragment on PriceTier {
              upTo
              unitPrice {
                amount
                currency
              }
              flatPrice {
                amount
                currency
              }
            }

            fragment ProvisionSubscriptionFragment on ProvisionSubscriptionResult {
              status
              checkoutUrl
              checkoutBillingId
              subscription {
                ...SlimSubscriptionFragment
              }
              entitlements {
                ...EntitlementFragment
              }
            }

            fragment ResetPeriodConfigurationFragment on ResetPeriodConfiguration {
              __typename
              ... on YearlyResetPeriodConfig {
                yearlyAccordingTo
              }
              ... on MonthlyResetPeriodConfig {
                monthlyAccordingTo
              }
              ... on WeeklyResetPeriodConfig {
                weeklyAccordingTo
              }
            }

            fragment SlimSubscriptionFragment on CustomerSubscription {
              id
              subscriptionId
              refId
              status
              additionalMetaData
              billingId
              billingLinkUrl
              effectiveEndDate
              cancellationDate
              currentBillingPeriodEnd
              pricingType
              latestInvoice {
                ...SubscriptionInvoiceFragment
              }
              paymentCollection
              billingSyncError
              resource {
                ...CustomerResourceFragment
              }
              experimentInfo {
                name
                id
                groupType
                groupName
              }
              prices {
                usageLimit
                price {
                  ...PriceFragment
                }
              }
              totalPrice {
                ...TotalPriceFragment
              }
              plan {
                id
                refId
              }
              addons {
                quantity
                addon {
                  id
                  refId
                }
              }
              customer {
                id
                refId
              }
            }

            fragment SubscriptionInvoiceFragment on SubscriptionInvoice {
              billingId
              status
              createdAt
              dueDate
              updatedAt
              errorMessage
              requiresAction
              paymentSecret
              paymentUrl
              pdfUrl
              billingReason
              currency
              subTotal
              subTotalExcludingTax
              total
              totalExcludingTax
              tax
              amountDue
              attemptCount
            }

            fragment TotalPriceFragment on CustomerSubscriptionTotalPrice {
              subTotal {
                amount
                currency
              }
              total {
                amount
                currency
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="ProvisionSubscription",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return ProvisionSubscription.model_validate(data)

    def apply_subscription(
        self, input: ApplySubscriptionInput, **kwargs: Any
    ) -> ApplySubscription:
        query = gql(
            """
            mutation ApplySubscription($input: ApplySubscriptionInput!) {
              applySubscription(input: $input) {
                ...ApplySubscriptionFragment
              }
            }

            fragment AddonDependencyFragment on Addon {
              id
              refId
              displayName
              description
            }

            fragment AddonFragment on Addon {
              id
              refId
              billingId
              displayName
              description
              additionalMetaData
              hiddenFromWidgets
              entitlements {
                ...PackageEntitlementFragment
              }
              prices {
                ...PriceFragment
              }
              overagePrices {
                ...OveragePriceFragment
              }
              pricingType
              maxQuantity
              dependencies {
                ...AddonDependencyFragment
              }
            }

            fragment ApplySubscriptionFragment on ApplySubscription {
              subscription {
                ...SubscriptionFragment
              }
              entitlements {
                ...EntitlementFragment
              }
            }

            fragment CustomerResourceFragment on CustomerResource {
              resourceId
            }

            fragment EntitlementFragment on Entitlement {
              __typename
              isGranted
              accessDeniedReason
              customerId
              resourceId
              usageLimit
              hasUnlimitedUsage
              hasSoftLimit
              currentUsage
              requestedUsage
              requestedValues
              enumValues
              entitlementUpdatedAt
              usageUpdatedAt
              usagePeriodAnchor
              usagePeriodStart
              usagePeriodEnd
              nextResetDate
              resetPeriod
              resetPeriodConfiguration {
                ...ResetPeriodConfigurationFragment
              }
              feature {
                ...FeatureFragment
              }
            }

            fragment FeatureFragment on EntitlementFeature {
              __typename
              featureType
              meterType
              featureUnits
              featureUnitsPlural
              description
              displayName
              refId
              unitTransformation {
                divide
                round
              }
            }

            fragment OveragePriceFragment on Price {
              billingModel
              billingPeriod
              billingId
              billingCountryCode
              price {
                amount
                currency
              }
              tiersMode
              tiers {
                ...PriceTierFragment
              }
              feature {
                refId
                featureUnits
                featureUnitsPlural
                displayName
                description
              }
            }

            fragment PackageEntitlementFragment on PackageEntitlement {
              usageLimit
              hasUnlimitedUsage
              hasSoftLimit
              featureId
              resetPeriod
              hiddenFromWidgets
              isCustom
              displayNameOverride
              enumValues
              feature {
                featureType
                meterType
                featureUnits
                featureUnitsPlural
                displayName
                description
                refId
                additionalMetaData
              }
            }

            fragment PlanCompatiblePackageGroupsFragment on PlanCompatiblePackageGroups {
              packageGroupId
              displayName
              addons {
                ...AddonFragment
              }
              options {
                minItems
                freeItems
              }
            }

            fragment PlanFragment on Plan {
              id
              refId
              displayName
              description
              billingId
              versionNumber
              additionalMetaData
              hiddenFromWidgets
              product {
                ...ProductFragment
              }
              basePlan {
                refId
                displayName
              }
              entitlements {
                ...PackageEntitlementFragment
              }
              inheritedEntitlements {
                ...PackageEntitlementFragment
              }
              compatibleAddons {
                ...AddonFragment
              }
              compatiblePackageGroups {
                ...PlanCompatiblePackageGroupsFragment
              }
              prices {
                ...PriceFragment
              }
              overagePrices {
                ...OveragePriceFragment
              }
              pricingType
              defaultTrialConfig {
                duration
                units
                budget {
                  limit
                }
                trialEndBehavior
              }
            }

            fragment PriceFragment on Price {
              billingModel
              billingPeriod
              billingCadence
              billingId
              minUnitQuantity
              maxUnitQuantity
              billingCountryCode
              price {
                amount
                currency
              }
              creditRate {
                amount
                customCurrencyId
              }
              tiersMode
              tiers {
                ...PriceTierFragment
              }
              feature {
                refId
                featureUnits
                featureUnitsPlural
                displayName
                description
              }
              blockSize
            }

            fragment PriceTierFragment on PriceTier {
              upTo
              unitPrice {
                amount
                currency
              }
              flatPrice {
                amount
                currency
              }
            }

            fragment ProductFragment on Product {
              refId
              displayName
              description
              additionalMetaData
              productSettings {
                downgradePlan {
                  refId
                  displayName
                }
              }
            }

            fragment ResetPeriodConfigurationFragment on ResetPeriodConfiguration {
              __typename
              ... on YearlyResetPeriodConfig {
                yearlyAccordingTo
              }
              ... on MonthlyResetPeriodConfig {
                monthlyAccordingTo
              }
              ... on WeeklyResetPeriodConfig {
                weeklyAccordingTo
              }
            }

            fragment ScheduleVariablesFragment on ScheduleVariables {
              __typename
              ... on PlanChangeVariables {
                planRefId
                changeType
                billingPeriod
                billableFeatures {
                  featureId
                  quantity
                }
                addons {
                  addonRefId
                  quantity
                }
                priceOverrides {
                  planRefId
                  addonRefId
                  featureId
                }
              }
              ... on DowngradeChangeVariables {
                downgradePlanRefId
                billingPeriod
                billableFeatures {
                  featureId
                  quantity
                }
                addons {
                  addonRefId
                  quantity
                }
                priceOverrides {
                  planRefId
                  addonRefId
                  featureId
                }
              }
              ... on BillingPeriodChangeVariables {
                billingPeriod
              }
              ... on UnitAmountChangeVariables {
                newUnitAmount
                featureId
              }
              ... on AddonChangeVariables {
                addonRefId
                newQuantity
              }
              ... on PlanPriceOverrideChangeVariables {
                planRefId
                featureId
              }
              ... on AddonPriceOverrideChangeVariables {
                addonRefId
                featureId
              }
            }

            fragment SlimCustomerFragment on Customer {
              id
              name
              email
              createdAt
              updatedAt
              refId
              customerId
              billingId
              additionalMetaData
              awsMarketplaceCustomerId
            }

            fragment SubscriptionFragment on CustomerSubscription {
              id
              subscriptionId
              payingCustomer {
                ...SlimCustomerFragment
              }
              startDate
              endDate
              trialEndDate
              cancellationDate
              effectiveEndDate
              status
              refId
              currentBillingPeriodEnd
              additionalMetaData
              billingId
              billingLinkUrl
              latestInvoice {
                ...SubscriptionInvoiceFragment
              }
              paymentCollection
              paymentCollectionMethod
              billingSyncError
              resource {
                ...CustomerResourceFragment
              }
              experimentInfo {
                name
                groupType
                groupName
                id
              }
              prices {
                usageLimit
                price {
                  ...PriceFragment
                }
              }
              totalPrice {
                ...TotalPriceFragment
              }
              pricingType
              plan {
                ...PlanFragment
              }
              addons {
                id
                quantity
                addon {
                  ...AddonFragment
                }
              }
              scheduledUpdates {
                ...SubscriptionScheduledUpdateData
              }
              futureUpdates {
                ...SubscriptionFutureUpdateData
              }
              trialConfiguration {
                ...SubscriptionTrialConfigurationFragment
              }
            }

            fragment SubscriptionFutureUpdateData on SubscriptionFutureUpdate {
              subscriptionScheduleType
              scheduleStatus
              scheduledExecutionTime
              targetPackage {
                id
                refId
                displayName
              }
              scheduleVariables {
                ...ScheduleVariablesFragment
              }
            }

            fragment SubscriptionInvoiceFragment on SubscriptionInvoice {
              billingId
              status
              createdAt
              dueDate
              updatedAt
              errorMessage
              requiresAction
              paymentSecret
              paymentUrl
              pdfUrl
              billingReason
              currency
              subTotal
              subTotalExcludingTax
              total
              totalExcludingTax
              tax
              amountDue
              attemptCount
            }

            fragment SubscriptionScheduledUpdateData on SubscriptionScheduledUpdate {
              subscriptionScheduleType
              scheduleStatus
              scheduledExecutionTime
              targetPackage {
                id
                refId
                displayName
              }
              scheduleVariables {
                ...ScheduleVariablesFragment
              }
            }

            fragment SubscriptionTrialConfigurationFragment on TrialConfiguration {
              trialEndBehavior
            }

            fragment TotalPriceFragment on CustomerSubscriptionTotalPrice {
              subTotal {
                amount
                currency
              }
              total {
                amount
                currency
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="ApplySubscription",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return ApplySubscription.model_validate(data)

    def import_subscriptions_bulk(
        self, input: ImportSubscriptionsBulkInput, **kwargs: Any
    ) -> ImportSubscriptionsBulk:
        query = gql(
            """
            mutation ImportSubscriptionsBulk($input: ImportSubscriptionsBulkInput!) {
              importSubscriptionsBulk(input: $input)
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="ImportSubscriptionsBulk",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return ImportSubscriptionsBulk.model_validate(data)

    def update_subscription(
        self, input: UpdateSubscriptionInput, **kwargs: Any
    ) -> UpdateSubscription:
        query = gql(
            """
            mutation UpdateSubscription($input: UpdateSubscriptionInput!) {
              updateSubscription: updateOneSubscription(input: $input) {
                ...SlimSubscriptionFragment
              }
            }

            fragment CustomerResourceFragment on CustomerResource {
              resourceId
            }

            fragment PriceFragment on Price {
              billingModel
              billingPeriod
              billingCadence
              billingId
              minUnitQuantity
              maxUnitQuantity
              billingCountryCode
              price {
                amount
                currency
              }
              creditRate {
                amount
                customCurrencyId
              }
              tiersMode
              tiers {
                ...PriceTierFragment
              }
              feature {
                refId
                featureUnits
                featureUnitsPlural
                displayName
                description
              }
              blockSize
            }

            fragment PriceTierFragment on PriceTier {
              upTo
              unitPrice {
                amount
                currency
              }
              flatPrice {
                amount
                currency
              }
            }

            fragment SlimSubscriptionFragment on CustomerSubscription {
              id
              subscriptionId
              refId
              status
              additionalMetaData
              billingId
              billingLinkUrl
              effectiveEndDate
              cancellationDate
              currentBillingPeriodEnd
              pricingType
              latestInvoice {
                ...SubscriptionInvoiceFragment
              }
              paymentCollection
              billingSyncError
              resource {
                ...CustomerResourceFragment
              }
              experimentInfo {
                name
                id
                groupType
                groupName
              }
              prices {
                usageLimit
                price {
                  ...PriceFragment
                }
              }
              totalPrice {
                ...TotalPriceFragment
              }
              plan {
                id
                refId
              }
              addons {
                quantity
                addon {
                  id
                  refId
                }
              }
              customer {
                id
                refId
              }
            }

            fragment SubscriptionInvoiceFragment on SubscriptionInvoice {
              billingId
              status
              createdAt
              dueDate
              updatedAt
              errorMessage
              requiresAction
              paymentSecret
              paymentUrl
              pdfUrl
              billingReason
              currency
              subTotal
              subTotalExcludingTax
              total
              totalExcludingTax
              tax
              amountDue
              attemptCount
            }

            fragment TotalPriceFragment on CustomerSubscriptionTotalPrice {
              subTotal {
                amount
                currency
              }
              total {
                amount
                currency
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="UpdateSubscription",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateSubscription.model_validate(data)

    def cancel_subscription(
        self, input: SubscriptionCancellationInput, **kwargs: Any
    ) -> CancelSubscription:
        query = gql(
            """
            mutation CancelSubscription($input: SubscriptionCancellationInput!) {
              cancelSubscription(input: $input) {
                ...SlimSubscriptionFragment
              }
            }

            fragment CustomerResourceFragment on CustomerResource {
              resourceId
            }

            fragment PriceFragment on Price {
              billingModel
              billingPeriod
              billingCadence
              billingId
              minUnitQuantity
              maxUnitQuantity
              billingCountryCode
              price {
                amount
                currency
              }
              creditRate {
                amount
                customCurrencyId
              }
              tiersMode
              tiers {
                ...PriceTierFragment
              }
              feature {
                refId
                featureUnits
                featureUnitsPlural
                displayName
                description
              }
              blockSize
            }

            fragment PriceTierFragment on PriceTier {
              upTo
              unitPrice {
                amount
                currency
              }
              flatPrice {
                amount
                currency
              }
            }

            fragment SlimSubscriptionFragment on CustomerSubscription {
              id
              subscriptionId
              refId
              status
              additionalMetaData
              billingId
              billingLinkUrl
              effectiveEndDate
              cancellationDate
              currentBillingPeriodEnd
              pricingType
              latestInvoice {
                ...SubscriptionInvoiceFragment
              }
              paymentCollection
              billingSyncError
              resource {
                ...CustomerResourceFragment
              }
              experimentInfo {
                name
                id
                groupType
                groupName
              }
              prices {
                usageLimit
                price {
                  ...PriceFragment
                }
              }
              totalPrice {
                ...TotalPriceFragment
              }
              plan {
                id
                refId
              }
              addons {
                quantity
                addon {
                  id
                  refId
                }
              }
              customer {
                id
                refId
              }
            }

            fragment SubscriptionInvoiceFragment on SubscriptionInvoice {
              billingId
              status
              createdAt
              dueDate
              updatedAt
              errorMessage
              requiresAction
              paymentSecret
              paymentUrl
              pdfUrl
              billingReason
              currency
              subTotal
              subTotalExcludingTax
              total
              totalExcludingTax
              tax
              amountDue
              attemptCount
            }

            fragment TotalPriceFragment on CustomerSubscriptionTotalPrice {
              subTotal {
                amount
                currency
              }
              total {
                amount
                currency
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="CancelSubscription",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CancelSubscription.model_validate(data)

    def estimate_subscription(
        self, input: EstimateSubscriptionInput, **kwargs: Any
    ) -> EstimateSubscription:
        query = gql(
            """
            mutation EstimateSubscription($input: EstimateSubscriptionInput!) {
              estimateSubscription(input: $input) {
                ...SubscriptionPreviewFragment
              }
            }

            fragment SubscriptionPreviewFragment on SubscriptionPreview {
              subTotal {
                amount
                currency
              }
              totalExcludingTax {
                amount
                currency
              }
              total {
                amount
                currency
              }
              discountAmount {
                amount
                currency
              }
              taxDetails {
                displayName
                percentage
                inclusive
              }
              tax {
                amount
                currency
              }
              billingPeriodRange {
                start
                end
              }
              discount {
                name
                type
                value
                durationType
                durationInMonths
              }
              subscription {
                subTotal {
                  amount
                  currency
                }
                totalExcludingTax {
                  amount
                  currency
                }
                total {
                  amount
                  currency
                }
                tax {
                  amount
                  currency
                }
                discountAmount {
                  amount
                  currency
                }
                taxDetails {
                  displayName
                  percentage
                  inclusive
                }
                discount {
                  name
                  type
                  value
                  durationType
                  durationInMonths
                }
              }
              proration {
                prorationDate
                credit {
                  amount
                  currency
                }
                debit {
                  amount
                  currency
                }
                netAmount {
                  amount
                  currency
                }
              }
              isPlanDowngrade
              hasScheduledUpdates
              credits {
                initial {
                  amount
                  currency
                }
                used {
                  amount
                  currency
                }
                remaining {
                  amount
                  currency
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="EstimateSubscription",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return EstimateSubscription.model_validate(data)

    def estimate_subscription_update(
        self, input: EstimateSubscriptionUpdateInput, **kwargs: Any
    ) -> EstimateSubscriptionUpdate:
        query = gql(
            """
            mutation EstimateSubscriptionUpdate($input: EstimateSubscriptionUpdateInput!) {
              estimateSubscriptionUpdate(input: $input) {
                ...SubscriptionPreviewFragment
              }
            }

            fragment SubscriptionPreviewFragment on SubscriptionPreview {
              subTotal {
                amount
                currency
              }
              totalExcludingTax {
                amount
                currency
              }
              total {
                amount
                currency
              }
              discountAmount {
                amount
                currency
              }
              taxDetails {
                displayName
                percentage
                inclusive
              }
              tax {
                amount
                currency
              }
              billingPeriodRange {
                start
                end
              }
              discount {
                name
                type
                value
                durationType
                durationInMonths
              }
              subscription {
                subTotal {
                  amount
                  currency
                }
                totalExcludingTax {
                  amount
                  currency
                }
                total {
                  amount
                  currency
                }
                tax {
                  amount
                  currency
                }
                discountAmount {
                  amount
                  currency
                }
                taxDetails {
                  displayName
                  percentage
                  inclusive
                }
                discount {
                  name
                  type
                  value
                  durationType
                  durationInMonths
                }
              }
              proration {
                prorationDate
                credit {
                  amount
                  currency
                }
                debit {
                  amount
                  currency
                }
                netAmount {
                  amount
                  currency
                }
              }
              isPlanDowngrade
              hasScheduledUpdates
              credits {
                initial {
                  amount
                  currency
                }
                used {
                  amount
                  currency
                }
                remaining {
                  amount
                  currency
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="EstimateSubscriptionUpdate",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return EstimateSubscriptionUpdate.model_validate(data)

    def preview_subscription(
        self, input: PreviewSubscriptionInput, **kwargs: Any
    ) -> PreviewSubscription:
        query = gql(
            """
            mutation PreviewSubscription($input: PreviewSubscriptionInput!) {
              previewSubscription(input: $input) {
                ...SubscriptionPreviewV2Fragment
              }
            }

            fragment ImmediateSubscriptionPreviewInvoiceFragment on ImmediateSubscriptionPreviewInvoice {
              total {
                amount
                currency
              }
              subTotal {
                amount
                currency
              }
              totalExcludingTax {
                amount
                currency
              }
              tax {
                amount
                currency
              }
              discount {
                amount
                currency
              }
              taxDetails {
                displayName
                percentage
                inclusive
              }
              discountDetails {
                type
                value
                durationType
                durationInMonths
              }
              credits {
                initial {
                  amount
                  currency
                }
                used {
                  amount
                  currency
                }
                remaining {
                  amount
                  currency
                }
              }
              proration {
                prorationDate
                hasProrations
                credit {
                  amount
                  currency
                }
                debit {
                  amount
                  currency
                }
                netAmount {
                  amount
                  currency
                }
              }
            }

            fragment SubscriptionPreviewInvoiceFragment on SubscriptionPreviewInvoice {
              total {
                amount
                currency
              }
              subTotal {
                amount
                currency
              }
              totalExcludingTax {
                amount
                currency
              }
              tax {
                amount
                currency
              }
              discount {
                amount
                currency
              }
              taxDetails {
                displayName
                percentage
                inclusive
              }
              discountDetails {
                type
                value
                durationType
                durationInMonths
              }
            }

            fragment SubscriptionPreviewV2Fragment on SubscriptionPreviewV2 {
              immediateInvoice {
                ...ImmediateSubscriptionPreviewInvoiceFragment
              }
              recurringInvoice {
                ...SubscriptionPreviewInvoiceFragment
              }
              billingPeriodRange {
                start
                end
              }
              isPlanDowngrade
              hasScheduledUpdates
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="PreviewSubscription",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return PreviewSubscription.model_validate(data)

    def preview_next_invoice(
        self, input: PreviewNextInvoiceInput, **kwargs: Any
    ) -> PreviewNextInvoice:
        query = gql(
            """
            mutation PreviewNextInvoice($input: PreviewNextInvoiceInput!) {
              previewNextInvoice(input: $input) {
                ...SubscriptionInvoicePreviewFragment
              }
            }

            fragment PriceFragment on Price {
              billingModel
              billingPeriod
              billingCadence
              billingId
              minUnitQuantity
              maxUnitQuantity
              billingCountryCode
              price {
                amount
                currency
              }
              creditRate {
                amount
                customCurrencyId
              }
              tiersMode
              tiers {
                ...PriceTierFragment
              }
              feature {
                refId
                featureUnits
                featureUnitsPlural
                displayName
                description
              }
              blockSize
            }

            fragment PriceTierFragment on PriceTier {
              upTo
              unitPrice {
                amount
                currency
              }
              flatPrice {
                amount
                currency
              }
            }

            fragment SubscriptionInvoicePreviewFragment on SubscriptionInvoicePreview {
              amountDue {
                amount
                currency
              }
              minimumSpendAdjustment {
                amount
                currency
              }
              total {
                amount
                currency
              }
              totalExcludingTax {
                amount
                currency
              }
              subTotal {
                amount
                currency
              }
              subTotalExcludingTax {
                amount
                currency
              }
              tax {
                amount
                currency
              }
              taxDetails {
                displayName
                percentage
                inclusive
              }
              discount {
                amount
                currency
              }
              discountDetails {
                name
                type
                value
                durationType
                durationInMonths
              }
              credits {
                initial {
                  amount
                  currency
                }
                used {
                  amount
                  currency
                }
                remaining {
                  amount
                  currency
                }
              }
              lastUpdatedAt
              lines {
                type
                description
                costDescription
                amount {
                  amount
                  currency
                }
                unitPrice {
                  amount
                  currency
                }
                quantity
                proration
                price {
                  ...PriceFragment
                }
                usageLimit
                period {
                  start
                  end
                }
                hasSoftLimit
                lines {
                  type
                  description
                  costDescription
                  quantity
                  proration
                  usageLimit
                  hasSoftLimit
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="PreviewNextInvoice",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return PreviewNextInvoice.model_validate(data)

    def cancel_subscription_updates(
        self, input: SubscriptionUpdateScheduleCancellationInput, **kwargs: Any
    ) -> CancelSubscriptionUpdates:
        query = gql(
            """
            mutation CancelSubscriptionUpdates($input: SubscriptionUpdateScheduleCancellationInput!) {
              cancelSchedule(input: $input)
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="CancelSubscriptionUpdates",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CancelSubscriptionUpdates.model_validate(data)

    def report_usage(self, input: ReportUsageInput, **kwargs: Any) -> ReportUsage:
        query = gql(
            """
            mutation ReportUsage($input: ReportUsageInput!) {
              reportUsage(input: $input) {
                ...ReportUsageFragment
              }
            }

            fragment ReportUsageFragment on UsageMeasurementWithCurrentUsage {
              id
              featureId
              customerId
              resourceId
              currentUsage
              usagePeriodStart
              usagePeriodEnd
              nextResetDate
              timestamp
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query, operation_name="ReportUsage", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return ReportUsage.model_validate(data)

    def report_usage_bulk(
        self, input: ReportUsageBulkInput, **kwargs: Any
    ) -> ReportUsageBulk:
        query = gql(
            """
            mutation ReportUsageBulk($input: ReportUsageBulkInput!) {
              reportUsageBulk(input: $input) {
                ...ReportUsageFragment
              }
            }

            fragment ReportUsageFragment on UsageMeasurementWithCurrentUsage {
              id
              featureId
              customerId
              resourceId
              currentUsage
              usagePeriodStart
              usagePeriodEnd
              nextResetDate
              timestamp
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query, operation_name="ReportUsageBulk", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return ReportUsageBulk.model_validate(data)

    def report_event(self, input: UsageEventsReportInput, **kwargs: Any) -> ReportEvent:
        query = gql(
            """
            mutation ReportEvent($input: UsageEventsReportInput!) {
              reportEvent(events: $input)
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query, operation_name="ReportEvent", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return ReportEvent.model_validate(data)

    def report_entitlement_check_requested(
        self, entitlement_check_requested: EntitlementCheckRequested, **kwargs: Any
    ) -> ReportEntitlementCheckRequested:
        query = gql(
            """
            mutation ReportEntitlementCheckRequested($entitlementCheckRequested: EntitlementCheckRequested!) {
              reportEntitlementCheckRequested(
                entitlementCheckRequested: $entitlementCheckRequested
              )
            }
            """
        )
        variables: Dict[str, object] = {
            "entitlementCheckRequested": entitlement_check_requested
        }
        response = self.execute(
            query=query,
            operation_name="ReportEntitlementCheckRequested",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return ReportEntitlementCheckRequested.model_validate(data)

    def create_subscription(
        self, input: SubscriptionInput, **kwargs: Any
    ) -> CreateSubscription:
        query = gql(
            """
            mutation CreateSubscription($input: SubscriptionInput!) {
              createSubscription(subscription: $input) {
                ...SlimSubscriptionFragment
              }
            }

            fragment CustomerResourceFragment on CustomerResource {
              resourceId
            }

            fragment PriceFragment on Price {
              billingModel
              billingPeriod
              billingCadence
              billingId
              minUnitQuantity
              maxUnitQuantity
              billingCountryCode
              price {
                amount
                currency
              }
              creditRate {
                amount
                customCurrencyId
              }
              tiersMode
              tiers {
                ...PriceTierFragment
              }
              feature {
                refId
                featureUnits
                featureUnitsPlural
                displayName
                description
              }
              blockSize
            }

            fragment PriceTierFragment on PriceTier {
              upTo
              unitPrice {
                amount
                currency
              }
              flatPrice {
                amount
                currency
              }
            }

            fragment SlimSubscriptionFragment on CustomerSubscription {
              id
              subscriptionId
              refId
              status
              additionalMetaData
              billingId
              billingLinkUrl
              effectiveEndDate
              cancellationDate
              currentBillingPeriodEnd
              pricingType
              latestInvoice {
                ...SubscriptionInvoiceFragment
              }
              paymentCollection
              billingSyncError
              resource {
                ...CustomerResourceFragment
              }
              experimentInfo {
                name
                id
                groupType
                groupName
              }
              prices {
                usageLimit
                price {
                  ...PriceFragment
                }
              }
              totalPrice {
                ...TotalPriceFragment
              }
              plan {
                id
                refId
              }
              addons {
                quantity
                addon {
                  id
                  refId
                }
              }
              customer {
                id
                refId
              }
            }

            fragment SubscriptionInvoiceFragment on SubscriptionInvoice {
              billingId
              status
              createdAt
              dueDate
              updatedAt
              errorMessage
              requiresAction
              paymentSecret
              paymentUrl
              pdfUrl
              billingReason
              currency
              subTotal
              subTotalExcludingTax
              total
              totalExcludingTax
              tax
              amountDue
              attemptCount
            }

            fragment TotalPriceFragment on CustomerSubscriptionTotalPrice {
              subTotal {
                amount
                currency
              }
              total {
                amount
                currency
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="CreateSubscription",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateSubscription.model_validate(data)

    def migrate_subscription_to_latest(
        self, input: SubscriptionMigrationInput, **kwargs: Any
    ) -> MigrateSubscriptionToLatest:
        query = gql(
            """
            mutation MigrateSubscriptionToLatest($input: SubscriptionMigrationInput!) {
              migrateSubscriptionToLatest(input: $input) {
                subscriptionId
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="MigrateSubscriptionToLatest",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return MigrateSubscriptionToLatest.model_validate(data)

    def archive_customer(
        self, input: ArchiveCustomerInput, **kwargs: Any
    ) -> ArchiveCustomer:
        query = gql(
            """
            mutation ArchiveCustomer($input: ArchiveCustomerInput!) {
              archiveCustomer(input: $input) {
                customerId
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query, operation_name="ArchiveCustomer", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return ArchiveCustomer.model_validate(data)

    def unarchive_customer(
        self, input: UnarchiveCustomerInput, **kwargs: Any
    ) -> UnarchiveCustomer:
        query = gql(
            """
            mutation UnarchiveCustomer($input: UnarchiveCustomerInput!) {
              unarchiveCustomer(input: $input) {
                ...SlimCustomerFragment
              }
            }

            fragment SlimCustomerFragment on Customer {
              id
              name
              email
              createdAt
              updatedAt
              refId
              customerId
              billingId
              additionalMetaData
              awsMarketplaceCustomerId
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="UnarchiveCustomer",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UnarchiveCustomer.model_validate(data)

    def transfer_subscription(
        self, input: TransferSubscriptionInput, **kwargs: Any
    ) -> TransferSubscription:
        query = gql(
            """
            mutation TransferSubscription($input: TransferSubscriptionInput!) {
              transferSubscription(input: $input) {
                ...SlimSubscriptionFragment
              }
            }

            fragment CustomerResourceFragment on CustomerResource {
              resourceId
            }

            fragment PriceFragment on Price {
              billingModel
              billingPeriod
              billingCadence
              billingId
              minUnitQuantity
              maxUnitQuantity
              billingCountryCode
              price {
                amount
                currency
              }
              creditRate {
                amount
                customCurrencyId
              }
              tiersMode
              tiers {
                ...PriceTierFragment
              }
              feature {
                refId
                featureUnits
                featureUnitsPlural
                displayName
                description
              }
              blockSize
            }

            fragment PriceTierFragment on PriceTier {
              upTo
              unitPrice {
                amount
                currency
              }
              flatPrice {
                amount
                currency
              }
            }

            fragment SlimSubscriptionFragment on CustomerSubscription {
              id
              subscriptionId
              refId
              status
              additionalMetaData
              billingId
              billingLinkUrl
              effectiveEndDate
              cancellationDate
              currentBillingPeriodEnd
              pricingType
              latestInvoice {
                ...SubscriptionInvoiceFragment
              }
              paymentCollection
              billingSyncError
              resource {
                ...CustomerResourceFragment
              }
              experimentInfo {
                name
                id
                groupType
                groupName
              }
              prices {
                usageLimit
                price {
                  ...PriceFragment
                }
              }
              totalPrice {
                ...TotalPriceFragment
              }
              plan {
                id
                refId
              }
              addons {
                quantity
                addon {
                  id
                  refId
                }
              }
              customer {
                id
                refId
              }
            }

            fragment SubscriptionInvoiceFragment on SubscriptionInvoice {
              billingId
              status
              createdAt
              dueDate
              updatedAt
              errorMessage
              requiresAction
              paymentSecret
              paymentUrl
              pdfUrl
              billingReason
              currency
              subTotal
              subTotalExcludingTax
              total
              totalExcludingTax
              tax
              amountDue
              attemptCount
            }

            fragment TotalPriceFragment on CustomerSubscriptionTotalPrice {
              subTotal {
                amount
                currency
              }
              total {
                amount
                currency
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="TransferSubscription",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return TransferSubscription.model_validate(data)

    def delegate_subscription_to_customer(
        self, input: DelegateSubscriptionToCustomerInput, **kwargs: Any
    ) -> DelegateSubscriptionToCustomer:
        query = gql(
            """
            mutation DelegateSubscriptionToCustomer($input: DelegateSubscriptionToCustomerInput!) {
              delegateSubscriptionToCustomer(input: $input) {
                ...SlimSubscriptionFragment
              }
            }

            fragment CustomerResourceFragment on CustomerResource {
              resourceId
            }

            fragment PriceFragment on Price {
              billingModel
              billingPeriod
              billingCadence
              billingId
              minUnitQuantity
              maxUnitQuantity
              billingCountryCode
              price {
                amount
                currency
              }
              creditRate {
                amount
                customCurrencyId
              }
              tiersMode
              tiers {
                ...PriceTierFragment
              }
              feature {
                refId
                featureUnits
                featureUnitsPlural
                displayName
                description
              }
              blockSize
            }

            fragment PriceTierFragment on PriceTier {
              upTo
              unitPrice {
                amount
                currency
              }
              flatPrice {
                amount
                currency
              }
            }

            fragment SlimSubscriptionFragment on CustomerSubscription {
              id
              subscriptionId
              refId
              status
              additionalMetaData
              billingId
              billingLinkUrl
              effectiveEndDate
              cancellationDate
              currentBillingPeriodEnd
              pricingType
              latestInvoice {
                ...SubscriptionInvoiceFragment
              }
              paymentCollection
              billingSyncError
              resource {
                ...CustomerResourceFragment
              }
              experimentInfo {
                name
                id
                groupType
                groupName
              }
              prices {
                usageLimit
                price {
                  ...PriceFragment
                }
              }
              totalPrice {
                ...TotalPriceFragment
              }
              plan {
                id
                refId
              }
              addons {
                quantity
                addon {
                  id
                  refId
                }
              }
              customer {
                id
                refId
              }
            }

            fragment SubscriptionInvoiceFragment on SubscriptionInvoice {
              billingId
              status
              createdAt
              dueDate
              updatedAt
              errorMessage
              requiresAction
              paymentSecret
              paymentUrl
              pdfUrl
              billingReason
              currency
              subTotal
              subTotalExcludingTax
              total
              totalExcludingTax
              tax
              amountDue
              attemptCount
            }

            fragment TotalPriceFragment on CustomerSubscriptionTotalPrice {
              subTotal {
                amount
                currency
              }
              total {
                amount
                currency
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="DelegateSubscriptionToCustomer",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DelegateSubscriptionToCustomer.model_validate(data)

    def transfer_subscription_to_resource(
        self, input: TransferSubscriptionToResourceInput, **kwargs: Any
    ) -> TransferSubscriptionToResource:
        query = gql(
            """
            mutation TransferSubscriptionToResource($input: TransferSubscriptionToResourceInput!) {
              transferSubscriptionToResource(input: $input) {
                ...SlimSubscriptionFragment
              }
            }

            fragment CustomerResourceFragment on CustomerResource {
              resourceId
            }

            fragment PriceFragment on Price {
              billingModel
              billingPeriod
              billingCadence
              billingId
              minUnitQuantity
              maxUnitQuantity
              billingCountryCode
              price {
                amount
                currency
              }
              creditRate {
                amount
                customCurrencyId
              }
              tiersMode
              tiers {
                ...PriceTierFragment
              }
              feature {
                refId
                featureUnits
                featureUnitsPlural
                displayName
                description
              }
              blockSize
            }

            fragment PriceTierFragment on PriceTier {
              upTo
              unitPrice {
                amount
                currency
              }
              flatPrice {
                amount
                currency
              }
            }

            fragment SlimSubscriptionFragment on CustomerSubscription {
              id
              subscriptionId
              refId
              status
              additionalMetaData
              billingId
              billingLinkUrl
              effectiveEndDate
              cancellationDate
              currentBillingPeriodEnd
              pricingType
              latestInvoice {
                ...SubscriptionInvoiceFragment
              }
              paymentCollection
              billingSyncError
              resource {
                ...CustomerResourceFragment
              }
              experimentInfo {
                name
                id
                groupType
                groupName
              }
              prices {
                usageLimit
                price {
                  ...PriceFragment
                }
              }
              totalPrice {
                ...TotalPriceFragment
              }
              plan {
                id
                refId
              }
              addons {
                quantity
                addon {
                  id
                  refId
                }
              }
              customer {
                id
                refId
              }
            }

            fragment SubscriptionInvoiceFragment on SubscriptionInvoice {
              billingId
              status
              createdAt
              dueDate
              updatedAt
              errorMessage
              requiresAction
              paymentSecret
              paymentUrl
              pdfUrl
              billingReason
              currency
              subTotal
              subTotalExcludingTax
              total
              totalExcludingTax
              tax
              amountDue
              attemptCount
            }

            fragment TotalPriceFragment on CustomerSubscriptionTotalPrice {
              subTotal {
                amount
                currency
              }
              total {
                amount
                currency
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="TransferSubscriptionToResource",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return TransferSubscriptionToResource.model_validate(data)

    def get_customer_by_id(
        self, input: GetCustomerByRefIdInput, **kwargs: Any
    ) -> GetCustomerById:
        query = gql(
            """
            query GetCustomerById($input: GetCustomerByRefIdInput!) {
              getCustomerByRefId(input: $input) {
                ...CustomerWithSubscriptionsFragment
              }
            }

            fragment AddonDependencyFragment on Addon {
              id
              refId
              displayName
              description
            }

            fragment AddonFragment on Addon {
              id
              refId
              billingId
              displayName
              description
              additionalMetaData
              hiddenFromWidgets
              entitlements {
                ...PackageEntitlementFragment
              }
              prices {
                ...PriceFragment
              }
              overagePrices {
                ...OveragePriceFragment
              }
              pricingType
              maxQuantity
              dependencies {
                ...AddonDependencyFragment
              }
            }

            fragment CouponFragment on Coupon {
              id
              discountValue
              percentOff
              amountsOff {
                amount
                currency
              }
              type
              additionalMetaData
              refId
              name
              description
              createdAt
              updatedAt
              billingId
              billingLinkUrl
              status
              syncStates {
                vendorIdentifier
                status
              }
            }

            fragment CustomerFragment on Customer {
              ...SlimCustomerFragment
              hasPaymentMethod
              hasActiveSubscription
              defaultPaymentExpirationMonth
              defaultPaymentExpirationYear
              defaultPaymentMethodLast4Digits
              defaultPaymentMethodType
              trialedPlans {
                productId
                productRefId
                planRefId
                planId
              }
              experimentInfo {
                groupType
                groupName
                id
                name
              }
              coupon {
                ...CouponFragment
              }
              eligibleForTrial {
                productId
                productRefId
                eligible
              }
              promotionalEntitlements {
                ...PromotionalEntitlementFragment
              }
            }

            fragment CustomerResourceFragment on CustomerResource {
              resourceId
            }

            fragment CustomerWithSubscriptionsFragment on Customer {
              ...CustomerFragment
              subscriptions {
                ...SubscriptionFragment
              }
            }

            fragment OveragePriceFragment on Price {
              billingModel
              billingPeriod
              billingId
              billingCountryCode
              price {
                amount
                currency
              }
              tiersMode
              tiers {
                ...PriceTierFragment
              }
              feature {
                refId
                featureUnits
                featureUnitsPlural
                displayName
                description
              }
            }

            fragment PackageEntitlementFragment on PackageEntitlement {
              usageLimit
              hasUnlimitedUsage
              hasSoftLimit
              featureId
              resetPeriod
              hiddenFromWidgets
              isCustom
              displayNameOverride
              enumValues
              feature {
                featureType
                meterType
                featureUnits
                featureUnitsPlural
                displayName
                description
                refId
                additionalMetaData
              }
            }

            fragment PlanCompatiblePackageGroupsFragment on PlanCompatiblePackageGroups {
              packageGroupId
              displayName
              addons {
                ...AddonFragment
              }
              options {
                minItems
                freeItems
              }
            }

            fragment PlanFragment on Plan {
              id
              refId
              displayName
              description
              billingId
              versionNumber
              additionalMetaData
              hiddenFromWidgets
              product {
                ...ProductFragment
              }
              basePlan {
                refId
                displayName
              }
              entitlements {
                ...PackageEntitlementFragment
              }
              inheritedEntitlements {
                ...PackageEntitlementFragment
              }
              compatibleAddons {
                ...AddonFragment
              }
              compatiblePackageGroups {
                ...PlanCompatiblePackageGroupsFragment
              }
              prices {
                ...PriceFragment
              }
              overagePrices {
                ...OveragePriceFragment
              }
              pricingType
              defaultTrialConfig {
                duration
                units
                budget {
                  limit
                }
                trialEndBehavior
              }
            }

            fragment PriceFragment on Price {
              billingModel
              billingPeriod
              billingCadence
              billingId
              minUnitQuantity
              maxUnitQuantity
              billingCountryCode
              price {
                amount
                currency
              }
              creditRate {
                amount
                customCurrencyId
              }
              tiersMode
              tiers {
                ...PriceTierFragment
              }
              feature {
                refId
                featureUnits
                featureUnitsPlural
                displayName
                description
              }
              blockSize
            }

            fragment PriceTierFragment on PriceTier {
              upTo
              unitPrice {
                amount
                currency
              }
              flatPrice {
                amount
                currency
              }
            }

            fragment ProductFragment on Product {
              refId
              displayName
              description
              additionalMetaData
              productSettings {
                downgradePlan {
                  refId
                  displayName
                }
              }
            }

            fragment PromotionalEntitlementFragment on PromotionalEntitlement {
              status
              usageLimit
              featureId
              hasUnlimitedUsage
              hasSoftLimit
              resetPeriod
              endDate
              isVisible
              feature {
                featureType
                meterType
                featureUnits
                featureUnitsPlural
                displayName
                description
                refId
                additionalMetaData
              }
            }

            fragment ScheduleVariablesFragment on ScheduleVariables {
              __typename
              ... on PlanChangeVariables {
                planRefId
                changeType
                billingPeriod
                billableFeatures {
                  featureId
                  quantity
                }
                addons {
                  addonRefId
                  quantity
                }
                priceOverrides {
                  planRefId
                  addonRefId
                  featureId
                }
              }
              ... on DowngradeChangeVariables {
                downgradePlanRefId
                billingPeriod
                billableFeatures {
                  featureId
                  quantity
                }
                addons {
                  addonRefId
                  quantity
                }
                priceOverrides {
                  planRefId
                  addonRefId
                  featureId
                }
              }
              ... on BillingPeriodChangeVariables {
                billingPeriod
              }
              ... on UnitAmountChangeVariables {
                newUnitAmount
                featureId
              }
              ... on AddonChangeVariables {
                addonRefId
                newQuantity
              }
              ... on PlanPriceOverrideChangeVariables {
                planRefId
                featureId
              }
              ... on AddonPriceOverrideChangeVariables {
                addonRefId
                featureId
              }
            }

            fragment SlimCustomerFragment on Customer {
              id
              name
              email
              createdAt
              updatedAt
              refId
              customerId
              billingId
              additionalMetaData
              awsMarketplaceCustomerId
            }

            fragment SubscriptionFragment on CustomerSubscription {
              id
              subscriptionId
              payingCustomer {
                ...SlimCustomerFragment
              }
              startDate
              endDate
              trialEndDate
              cancellationDate
              effectiveEndDate
              status
              refId
              currentBillingPeriodEnd
              additionalMetaData
              billingId
              billingLinkUrl
              latestInvoice {
                ...SubscriptionInvoiceFragment
              }
              paymentCollection
              paymentCollectionMethod
              billingSyncError
              resource {
                ...CustomerResourceFragment
              }
              experimentInfo {
                name
                groupType
                groupName
                id
              }
              prices {
                usageLimit
                price {
                  ...PriceFragment
                }
              }
              totalPrice {
                ...TotalPriceFragment
              }
              pricingType
              plan {
                ...PlanFragment
              }
              addons {
                id
                quantity
                addon {
                  ...AddonFragment
                }
              }
              scheduledUpdates {
                ...SubscriptionScheduledUpdateData
              }
              futureUpdates {
                ...SubscriptionFutureUpdateData
              }
              trialConfiguration {
                ...SubscriptionTrialConfigurationFragment
              }
            }

            fragment SubscriptionFutureUpdateData on SubscriptionFutureUpdate {
              subscriptionScheduleType
              scheduleStatus
              scheduledExecutionTime
              targetPackage {
                id
                refId
                displayName
              }
              scheduleVariables {
                ...ScheduleVariablesFragment
              }
            }

            fragment SubscriptionInvoiceFragment on SubscriptionInvoice {
              billingId
              status
              createdAt
              dueDate
              updatedAt
              errorMessage
              requiresAction
              paymentSecret
              paymentUrl
              pdfUrl
              billingReason
              currency
              subTotal
              subTotalExcludingTax
              total
              totalExcludingTax
              tax
              amountDue
              attemptCount
            }

            fragment SubscriptionScheduledUpdateData on SubscriptionScheduledUpdate {
              subscriptionScheduleType
              scheduleStatus
              scheduledExecutionTime
              targetPackage {
                id
                refId
                displayName
              }
              scheduleVariables {
                ...ScheduleVariablesFragment
              }
            }

            fragment SubscriptionTrialConfigurationFragment on TrialConfiguration {
              trialEndBehavior
            }

            fragment TotalPriceFragment on CustomerSubscriptionTotalPrice {
              subTotal {
                amount
                currency
              }
              total {
                amount
                currency
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query, operation_name="GetCustomerById", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return GetCustomerById.model_validate(data)

    def get_customer_statistics(
        self, input: GetCustomerByRefIdInput, **kwargs: Any
    ) -> GetCustomerStatistics:
        query = gql(
            """
            query GetCustomerStatistics($input: GetCustomerByRefIdInput!) {
              getCustomerByRefId(input: $input) {
                ...CustomerStatisticsFragment
              }
            }

            fragment CustomerStatisticsFragment on Customer {
              statistics {
                activeSubscriptionsByPricingType {
                  pricingType
                  totalCount
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="GetCustomerStatistics",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetCustomerStatistics.model_validate(data)

    def get_active_subscriptions(
        self, input: GetActiveSubscriptionsInput, **kwargs: Any
    ) -> GetActiveSubscriptions:
        query = gql(
            """
            query GetActiveSubscriptions($input: GetActiveSubscriptionsInput!) {
              getActiveSubscriptions(input: $input) {
                ...SubscriptionFragment
              }
            }

            fragment AddonDependencyFragment on Addon {
              id
              refId
              displayName
              description
            }

            fragment AddonFragment on Addon {
              id
              refId
              billingId
              displayName
              description
              additionalMetaData
              hiddenFromWidgets
              entitlements {
                ...PackageEntitlementFragment
              }
              prices {
                ...PriceFragment
              }
              overagePrices {
                ...OveragePriceFragment
              }
              pricingType
              maxQuantity
              dependencies {
                ...AddonDependencyFragment
              }
            }

            fragment CustomerResourceFragment on CustomerResource {
              resourceId
            }

            fragment OveragePriceFragment on Price {
              billingModel
              billingPeriod
              billingId
              billingCountryCode
              price {
                amount
                currency
              }
              tiersMode
              tiers {
                ...PriceTierFragment
              }
              feature {
                refId
                featureUnits
                featureUnitsPlural
                displayName
                description
              }
            }

            fragment PackageEntitlementFragment on PackageEntitlement {
              usageLimit
              hasUnlimitedUsage
              hasSoftLimit
              featureId
              resetPeriod
              hiddenFromWidgets
              isCustom
              displayNameOverride
              enumValues
              feature {
                featureType
                meterType
                featureUnits
                featureUnitsPlural
                displayName
                description
                refId
                additionalMetaData
              }
            }

            fragment PlanCompatiblePackageGroupsFragment on PlanCompatiblePackageGroups {
              packageGroupId
              displayName
              addons {
                ...AddonFragment
              }
              options {
                minItems
                freeItems
              }
            }

            fragment PlanFragment on Plan {
              id
              refId
              displayName
              description
              billingId
              versionNumber
              additionalMetaData
              hiddenFromWidgets
              product {
                ...ProductFragment
              }
              basePlan {
                refId
                displayName
              }
              entitlements {
                ...PackageEntitlementFragment
              }
              inheritedEntitlements {
                ...PackageEntitlementFragment
              }
              compatibleAddons {
                ...AddonFragment
              }
              compatiblePackageGroups {
                ...PlanCompatiblePackageGroupsFragment
              }
              prices {
                ...PriceFragment
              }
              overagePrices {
                ...OveragePriceFragment
              }
              pricingType
              defaultTrialConfig {
                duration
                units
                budget {
                  limit
                }
                trialEndBehavior
              }
            }

            fragment PriceFragment on Price {
              billingModel
              billingPeriod
              billingCadence
              billingId
              minUnitQuantity
              maxUnitQuantity
              billingCountryCode
              price {
                amount
                currency
              }
              creditRate {
                amount
                customCurrencyId
              }
              tiersMode
              tiers {
                ...PriceTierFragment
              }
              feature {
                refId
                featureUnits
                featureUnitsPlural
                displayName
                description
              }
              blockSize
            }

            fragment PriceTierFragment on PriceTier {
              upTo
              unitPrice {
                amount
                currency
              }
              flatPrice {
                amount
                currency
              }
            }

            fragment ProductFragment on Product {
              refId
              displayName
              description
              additionalMetaData
              productSettings {
                downgradePlan {
                  refId
                  displayName
                }
              }
            }

            fragment ScheduleVariablesFragment on ScheduleVariables {
              __typename
              ... on PlanChangeVariables {
                planRefId
                changeType
                billingPeriod
                billableFeatures {
                  featureId
                  quantity
                }
                addons {
                  addonRefId
                  quantity
                }
                priceOverrides {
                  planRefId
                  addonRefId
                  featureId
                }
              }
              ... on DowngradeChangeVariables {
                downgradePlanRefId
                billingPeriod
                billableFeatures {
                  featureId
                  quantity
                }
                addons {
                  addonRefId
                  quantity
                }
                priceOverrides {
                  planRefId
                  addonRefId
                  featureId
                }
              }
              ... on BillingPeriodChangeVariables {
                billingPeriod
              }
              ... on UnitAmountChangeVariables {
                newUnitAmount
                featureId
              }
              ... on AddonChangeVariables {
                addonRefId
                newQuantity
              }
              ... on PlanPriceOverrideChangeVariables {
                planRefId
                featureId
              }
              ... on AddonPriceOverrideChangeVariables {
                addonRefId
                featureId
              }
            }

            fragment SlimCustomerFragment on Customer {
              id
              name
              email
              createdAt
              updatedAt
              refId
              customerId
              billingId
              additionalMetaData
              awsMarketplaceCustomerId
            }

            fragment SubscriptionFragment on CustomerSubscription {
              id
              subscriptionId
              payingCustomer {
                ...SlimCustomerFragment
              }
              startDate
              endDate
              trialEndDate
              cancellationDate
              effectiveEndDate
              status
              refId
              currentBillingPeriodEnd
              additionalMetaData
              billingId
              billingLinkUrl
              latestInvoice {
                ...SubscriptionInvoiceFragment
              }
              paymentCollection
              paymentCollectionMethod
              billingSyncError
              resource {
                ...CustomerResourceFragment
              }
              experimentInfo {
                name
                groupType
                groupName
                id
              }
              prices {
                usageLimit
                price {
                  ...PriceFragment
                }
              }
              totalPrice {
                ...TotalPriceFragment
              }
              pricingType
              plan {
                ...PlanFragment
              }
              addons {
                id
                quantity
                addon {
                  ...AddonFragment
                }
              }
              scheduledUpdates {
                ...SubscriptionScheduledUpdateData
              }
              futureUpdates {
                ...SubscriptionFutureUpdateData
              }
              trialConfiguration {
                ...SubscriptionTrialConfigurationFragment
              }
            }

            fragment SubscriptionFutureUpdateData on SubscriptionFutureUpdate {
              subscriptionScheduleType
              scheduleStatus
              scheduledExecutionTime
              targetPackage {
                id
                refId
                displayName
              }
              scheduleVariables {
                ...ScheduleVariablesFragment
              }
            }

            fragment SubscriptionInvoiceFragment on SubscriptionInvoice {
              billingId
              status
              createdAt
              dueDate
              updatedAt
              errorMessage
              requiresAction
              paymentSecret
              paymentUrl
              pdfUrl
              billingReason
              currency
              subTotal
              subTotalExcludingTax
              total
              totalExcludingTax
              tax
              amountDue
              attemptCount
            }

            fragment SubscriptionScheduledUpdateData on SubscriptionScheduledUpdate {
              subscriptionScheduleType
              scheduleStatus
              scheduledExecutionTime
              targetPackage {
                id
                refId
                displayName
              }
              scheduleVariables {
                ...ScheduleVariablesFragment
              }
            }

            fragment SubscriptionTrialConfigurationFragment on TrialConfiguration {
              trialEndBehavior
            }

            fragment TotalPriceFragment on CustomerSubscriptionTotalPrice {
              subTotal {
                amount
                currency
              }
              total {
                amount
                currency
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="GetActiveSubscriptions",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetActiveSubscriptions.model_validate(data)

    def get_active_subscriptions_list(
        self, input: GetActiveSubscriptionsInput, **kwargs: Any
    ) -> GetActiveSubscriptionsList:
        query = gql(
            """
            query GetActiveSubscriptionsList($input: GetActiveSubscriptionsInput!) {
              getActiveSubscriptions(input: $input) {
                ...SlimSubscriptionFragmentV2
              }
            }

            fragment SlimSubscriptionFragmentV2 on CustomerSubscription {
              subscriptionId
              status
              pricingType
              startDate
              cancellationDate
              currentBillingPeriodEnd
              customer {
                customerId
              }
              payingCustomer {
                customerId
              }
              resource {
                resourceId
              }
              plan {
                planId: refId
                displayName
              }
              addons {
                quantity
                addon {
                  addonId: refId
                }
              }
              trialConfiguration {
                trialEndBehavior
              }
              trialEndDate
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="GetActiveSubscriptionsList",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetActiveSubscriptionsList.model_validate(data)

    def get_subscriptions(
        self,
        filter: Union[Optional[SubscriptionQueryFilter], UnsetType] = UNSET,
        paging: Union[Optional[CursorPaging], UnsetType] = UNSET,
        sorting: Union[Optional[List[SubscriptionQuerySort]], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetSubscriptions:
        query = gql(
            """
            query GetSubscriptions($filter: SubscriptionQueryFilter, $paging: CursorPaging, $sorting: [SubscriptionQuerySort!]) {
              subscriptions(filter: $filter, paging: $paging, sorting: $sorting) {
                edges {
                  node {
                    ...SubscriptionQueryFragment
                  }
                }
                pageInfo {
                  ...PageInfoFragment
                }
              }
            }

            fragment PageInfoFragment on PageInfo {
              startCursor
              endCursor
              hasNextPage
              hasPreviousPage
            }

            fragment SubscriptionQueryFragment on SubscriptionQuery {
              subscriptionId
              status
              pricingType
              startDate
              currentBillingPeriodEnd
              customer {
                customerId
              }
              payingCustomer {
                customerId
              }
              resource {
                resourceId
              }
              plan {
                planId: refId
                displayName
              }
              addons {
                quantity
                addon {
                  addonId: refId
                }
              }
              trialConfiguration {
                trialEndBehavior
              }
              trialEndDate
            }
            """
        )
        variables: Dict[str, object] = {
            "filter": filter,
            "paging": paging,
            "sorting": sorting,
        }
        response = self.execute(
            query=query,
            operation_name="GetSubscriptions",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetSubscriptions.model_validate(data)

    def get_subscription(
        self, input: GetSubscriptionInput, **kwargs: Any
    ) -> GetSubscription:
        query = gql(
            """
            query GetSubscription($input: GetSubscriptionInput!) {
              getSubscription(input: $input) {
                ...SubscriptionFragment
              }
            }

            fragment AddonDependencyFragment on Addon {
              id
              refId
              displayName
              description
            }

            fragment AddonFragment on Addon {
              id
              refId
              billingId
              displayName
              description
              additionalMetaData
              hiddenFromWidgets
              entitlements {
                ...PackageEntitlementFragment
              }
              prices {
                ...PriceFragment
              }
              overagePrices {
                ...OveragePriceFragment
              }
              pricingType
              maxQuantity
              dependencies {
                ...AddonDependencyFragment
              }
            }

            fragment CustomerResourceFragment on CustomerResource {
              resourceId
            }

            fragment OveragePriceFragment on Price {
              billingModel
              billingPeriod
              billingId
              billingCountryCode
              price {
                amount
                currency
              }
              tiersMode
              tiers {
                ...PriceTierFragment
              }
              feature {
                refId
                featureUnits
                featureUnitsPlural
                displayName
                description
              }
            }

            fragment PackageEntitlementFragment on PackageEntitlement {
              usageLimit
              hasUnlimitedUsage
              hasSoftLimit
              featureId
              resetPeriod
              hiddenFromWidgets
              isCustom
              displayNameOverride
              enumValues
              feature {
                featureType
                meterType
                featureUnits
                featureUnitsPlural
                displayName
                description
                refId
                additionalMetaData
              }
            }

            fragment PlanCompatiblePackageGroupsFragment on PlanCompatiblePackageGroups {
              packageGroupId
              displayName
              addons {
                ...AddonFragment
              }
              options {
                minItems
                freeItems
              }
            }

            fragment PlanFragment on Plan {
              id
              refId
              displayName
              description
              billingId
              versionNumber
              additionalMetaData
              hiddenFromWidgets
              product {
                ...ProductFragment
              }
              basePlan {
                refId
                displayName
              }
              entitlements {
                ...PackageEntitlementFragment
              }
              inheritedEntitlements {
                ...PackageEntitlementFragment
              }
              compatibleAddons {
                ...AddonFragment
              }
              compatiblePackageGroups {
                ...PlanCompatiblePackageGroupsFragment
              }
              prices {
                ...PriceFragment
              }
              overagePrices {
                ...OveragePriceFragment
              }
              pricingType
              defaultTrialConfig {
                duration
                units
                budget {
                  limit
                }
                trialEndBehavior
              }
            }

            fragment PriceFragment on Price {
              billingModel
              billingPeriod
              billingCadence
              billingId
              minUnitQuantity
              maxUnitQuantity
              billingCountryCode
              price {
                amount
                currency
              }
              creditRate {
                amount
                customCurrencyId
              }
              tiersMode
              tiers {
                ...PriceTierFragment
              }
              feature {
                refId
                featureUnits
                featureUnitsPlural
                displayName
                description
              }
              blockSize
            }

            fragment PriceTierFragment on PriceTier {
              upTo
              unitPrice {
                amount
                currency
              }
              flatPrice {
                amount
                currency
              }
            }

            fragment ProductFragment on Product {
              refId
              displayName
              description
              additionalMetaData
              productSettings {
                downgradePlan {
                  refId
                  displayName
                }
              }
            }

            fragment ScheduleVariablesFragment on ScheduleVariables {
              __typename
              ... on PlanChangeVariables {
                planRefId
                changeType
                billingPeriod
                billableFeatures {
                  featureId
                  quantity
                }
                addons {
                  addonRefId
                  quantity
                }
                priceOverrides {
                  planRefId
                  addonRefId
                  featureId
                }
              }
              ... on DowngradeChangeVariables {
                downgradePlanRefId
                billingPeriod
                billableFeatures {
                  featureId
                  quantity
                }
                addons {
                  addonRefId
                  quantity
                }
                priceOverrides {
                  planRefId
                  addonRefId
                  featureId
                }
              }
              ... on BillingPeriodChangeVariables {
                billingPeriod
              }
              ... on UnitAmountChangeVariables {
                newUnitAmount
                featureId
              }
              ... on AddonChangeVariables {
                addonRefId
                newQuantity
              }
              ... on PlanPriceOverrideChangeVariables {
                planRefId
                featureId
              }
              ... on AddonPriceOverrideChangeVariables {
                addonRefId
                featureId
              }
            }

            fragment SlimCustomerFragment on Customer {
              id
              name
              email
              createdAt
              updatedAt
              refId
              customerId
              billingId
              additionalMetaData
              awsMarketplaceCustomerId
            }

            fragment SubscriptionFragment on CustomerSubscription {
              id
              subscriptionId
              payingCustomer {
                ...SlimCustomerFragment
              }
              startDate
              endDate
              trialEndDate
              cancellationDate
              effectiveEndDate
              status
              refId
              currentBillingPeriodEnd
              additionalMetaData
              billingId
              billingLinkUrl
              latestInvoice {
                ...SubscriptionInvoiceFragment
              }
              paymentCollection
              paymentCollectionMethod
              billingSyncError
              resource {
                ...CustomerResourceFragment
              }
              experimentInfo {
                name
                groupType
                groupName
                id
              }
              prices {
                usageLimit
                price {
                  ...PriceFragment
                }
              }
              totalPrice {
                ...TotalPriceFragment
              }
              pricingType
              plan {
                ...PlanFragment
              }
              addons {
                id
                quantity
                addon {
                  ...AddonFragment
                }
              }
              scheduledUpdates {
                ...SubscriptionScheduledUpdateData
              }
              futureUpdates {
                ...SubscriptionFutureUpdateData
              }
              trialConfiguration {
                ...SubscriptionTrialConfigurationFragment
              }
            }

            fragment SubscriptionFutureUpdateData on SubscriptionFutureUpdate {
              subscriptionScheduleType
              scheduleStatus
              scheduledExecutionTime
              targetPackage {
                id
                refId
                displayName
              }
              scheduleVariables {
                ...ScheduleVariablesFragment
              }
            }

            fragment SubscriptionInvoiceFragment on SubscriptionInvoice {
              billingId
              status
              createdAt
              dueDate
              updatedAt
              errorMessage
              requiresAction
              paymentSecret
              paymentUrl
              pdfUrl
              billingReason
              currency
              subTotal
              subTotalExcludingTax
              total
              totalExcludingTax
              tax
              amountDue
              attemptCount
            }

            fragment SubscriptionScheduledUpdateData on SubscriptionScheduledUpdate {
              subscriptionScheduleType
              scheduleStatus
              scheduledExecutionTime
              targetPackage {
                id
                refId
                displayName
              }
              scheduleVariables {
                ...ScheduleVariablesFragment
              }
            }

            fragment SubscriptionTrialConfigurationFragment on TrialConfiguration {
              trialEndBehavior
            }

            fragment TotalPriceFragment on CustomerSubscriptionTotalPrice {
              subTotal {
                amount
                currency
              }
              total {
                amount
                currency
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query, operation_name="GetSubscription", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return GetSubscription.model_validate(data)

    def get_coupons(self, **kwargs: Any) -> GetCoupons:
        query = gql(
            """
            query GetCoupons {
              coupons(filter: {status: {eq: ACTIVE}}, paging: {first: 50}) {
                edges {
                  node {
                    ...CouponFragment
                  }
                }
              }
            }

            fragment CouponFragment on Coupon {
              id
              discountValue
              percentOff
              amountsOff {
                amount
                currency
              }
              type
              additionalMetaData
              refId
              name
              description
              createdAt
              updatedAt
              billingId
              billingLinkUrl
              status
              syncStates {
                vendorIdentifier
                status
              }
            }
            """
        )
        variables: Dict[str, object] = {}
        response = self.execute(
            query=query, operation_name="GetCoupons", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return GetCoupons.model_validate(data)

    def get_paywall(self, input: GetPaywallInput, **kwargs: Any) -> GetPaywall:
        query = gql(
            """
            query GetPaywall($input: GetPaywallInput!) {
              paywall(input: $input) {
                ...PaywallFragment
              }
            }

            fragment AddonDependencyFragment on Addon {
              id
              refId
              displayName
              description
            }

            fragment AddonFragment on Addon {
              id
              refId
              billingId
              displayName
              description
              additionalMetaData
              hiddenFromWidgets
              entitlements {
                ...PackageEntitlementFragment
              }
              prices {
                ...PriceFragment
              }
              overagePrices {
                ...OveragePriceFragment
              }
              pricingType
              maxQuantity
              dependencies {
                ...AddonDependencyFragment
              }
            }

            fragment CouponFragment on Coupon {
              id
              discountValue
              percentOff
              amountsOff {
                amount
                currency
              }
              type
              additionalMetaData
              refId
              name
              description
              createdAt
              updatedAt
              billingId
              billingLinkUrl
              status
              syncStates {
                vendorIdentifier
                status
              }
            }

            fragment CustomerFragment on Customer {
              ...SlimCustomerFragment
              hasPaymentMethod
              hasActiveSubscription
              defaultPaymentExpirationMonth
              defaultPaymentExpirationYear
              defaultPaymentMethodLast4Digits
              defaultPaymentMethodType
              trialedPlans {
                productId
                productRefId
                planRefId
                planId
              }
              experimentInfo {
                groupType
                groupName
                id
                name
              }
              coupon {
                ...CouponFragment
              }
              eligibleForTrial {
                productId
                productRefId
                eligible
              }
              promotionalEntitlements {
                ...PromotionalEntitlementFragment
              }
            }

            fragment CustomerResourceFragment on CustomerResource {
              resourceId
            }

            fragment FontVariantFragment on FontVariant {
              fontSize
              fontWeight
            }

            fragment LayoutConfigurationFragment on PaywallLayoutConfiguration {
              alignment
              planWidth
              planMargin
              planPadding
            }

            fragment OveragePriceFragment on Price {
              billingModel
              billingPeriod
              billingId
              billingCountryCode
              price {
                amount
                currency
              }
              tiersMode
              tiers {
                ...PriceTierFragment
              }
              feature {
                refId
                featureUnits
                featureUnitsPlural
                displayName
                description
              }
            }

            fragment PackageEntitlementFragment on PackageEntitlement {
              usageLimit
              hasUnlimitedUsage
              hasSoftLimit
              featureId
              resetPeriod
              hiddenFromWidgets
              isCustom
              displayNameOverride
              enumValues
              feature {
                featureType
                meterType
                featureUnits
                featureUnitsPlural
                displayName
                description
                refId
                additionalMetaData
              }
            }

            fragment PaywallCalculatedPricePointsFragment on PaywallPricePoint {
              planId
              additionalChargesMayApply
              billingPeriod
              amount
              currency
              billingCountryCode
              feature {
                refId
                featureUnits
                featureUnitsPlural
                displayName
                description
              }
            }

            fragment PaywallConfigurationFragment on PaywallConfiguration {
              palette {
                primary
                textColor
                backgroundColor
                borderColor
                currentPlanBackground
              }
              typography {
                ...TypographyConfigurationFragment
              }
              layout {
                ...LayoutConfigurationFragment
              }
              customCss
            }

            fragment PaywallCurrencyFragment on PaywallCurrency {
              code
              symbol
            }

            fragment PaywallFragment on Paywall {
              plans {
                ...PlanFragment
              }
              currency {
                ...PaywallCurrencyFragment
              }
              configuration {
                ...PaywallConfigurationFragment
              }
              customer {
                ...CustomerFragment
              }
              activeSubscriptions {
                ...SubscriptionFragment
              }
              resource {
                ...CustomerResourceFragment
              }
              paywallCalculatedPricePoints {
                ...PaywallCalculatedPricePointsFragment
              }
            }

            fragment PlanCompatiblePackageGroupsFragment on PlanCompatiblePackageGroups {
              packageGroupId
              displayName
              addons {
                ...AddonFragment
              }
              options {
                minItems
                freeItems
              }
            }

            fragment PlanFragment on Plan {
              id
              refId
              displayName
              description
              billingId
              versionNumber
              additionalMetaData
              hiddenFromWidgets
              product {
                ...ProductFragment
              }
              basePlan {
                refId
                displayName
              }
              entitlements {
                ...PackageEntitlementFragment
              }
              inheritedEntitlements {
                ...PackageEntitlementFragment
              }
              compatibleAddons {
                ...AddonFragment
              }
              compatiblePackageGroups {
                ...PlanCompatiblePackageGroupsFragment
              }
              prices {
                ...PriceFragment
              }
              overagePrices {
                ...OveragePriceFragment
              }
              pricingType
              defaultTrialConfig {
                duration
                units
                budget {
                  limit
                }
                trialEndBehavior
              }
            }

            fragment PriceFragment on Price {
              billingModel
              billingPeriod
              billingCadence
              billingId
              minUnitQuantity
              maxUnitQuantity
              billingCountryCode
              price {
                amount
                currency
              }
              creditRate {
                amount
                customCurrencyId
              }
              tiersMode
              tiers {
                ...PriceTierFragment
              }
              feature {
                refId
                featureUnits
                featureUnitsPlural
                displayName
                description
              }
              blockSize
            }

            fragment PriceTierFragment on PriceTier {
              upTo
              unitPrice {
                amount
                currency
              }
              flatPrice {
                amount
                currency
              }
            }

            fragment ProductFragment on Product {
              refId
              displayName
              description
              additionalMetaData
              productSettings {
                downgradePlan {
                  refId
                  displayName
                }
              }
            }

            fragment PromotionalEntitlementFragment on PromotionalEntitlement {
              status
              usageLimit
              featureId
              hasUnlimitedUsage
              hasSoftLimit
              resetPeriod
              endDate
              isVisible
              feature {
                featureType
                meterType
                featureUnits
                featureUnitsPlural
                displayName
                description
                refId
                additionalMetaData
              }
            }

            fragment ScheduleVariablesFragment on ScheduleVariables {
              __typename
              ... on PlanChangeVariables {
                planRefId
                changeType
                billingPeriod
                billableFeatures {
                  featureId
                  quantity
                }
                addons {
                  addonRefId
                  quantity
                }
                priceOverrides {
                  planRefId
                  addonRefId
                  featureId
                }
              }
              ... on DowngradeChangeVariables {
                downgradePlanRefId
                billingPeriod
                billableFeatures {
                  featureId
                  quantity
                }
                addons {
                  addonRefId
                  quantity
                }
                priceOverrides {
                  planRefId
                  addonRefId
                  featureId
                }
              }
              ... on BillingPeriodChangeVariables {
                billingPeriod
              }
              ... on UnitAmountChangeVariables {
                newUnitAmount
                featureId
              }
              ... on AddonChangeVariables {
                addonRefId
                newQuantity
              }
              ... on PlanPriceOverrideChangeVariables {
                planRefId
                featureId
              }
              ... on AddonPriceOverrideChangeVariables {
                addonRefId
                featureId
              }
            }

            fragment SlimCustomerFragment on Customer {
              id
              name
              email
              createdAt
              updatedAt
              refId
              customerId
              billingId
              additionalMetaData
              awsMarketplaceCustomerId
            }

            fragment SubscriptionFragment on CustomerSubscription {
              id
              subscriptionId
              payingCustomer {
                ...SlimCustomerFragment
              }
              startDate
              endDate
              trialEndDate
              cancellationDate
              effectiveEndDate
              status
              refId
              currentBillingPeriodEnd
              additionalMetaData
              billingId
              billingLinkUrl
              latestInvoice {
                ...SubscriptionInvoiceFragment
              }
              paymentCollection
              paymentCollectionMethod
              billingSyncError
              resource {
                ...CustomerResourceFragment
              }
              experimentInfo {
                name
                groupType
                groupName
                id
              }
              prices {
                usageLimit
                price {
                  ...PriceFragment
                }
              }
              totalPrice {
                ...TotalPriceFragment
              }
              pricingType
              plan {
                ...PlanFragment
              }
              addons {
                id
                quantity
                addon {
                  ...AddonFragment
                }
              }
              scheduledUpdates {
                ...SubscriptionScheduledUpdateData
              }
              futureUpdates {
                ...SubscriptionFutureUpdateData
              }
              trialConfiguration {
                ...SubscriptionTrialConfigurationFragment
              }
            }

            fragment SubscriptionFutureUpdateData on SubscriptionFutureUpdate {
              subscriptionScheduleType
              scheduleStatus
              scheduledExecutionTime
              targetPackage {
                id
                refId
                displayName
              }
              scheduleVariables {
                ...ScheduleVariablesFragment
              }
            }

            fragment SubscriptionInvoiceFragment on SubscriptionInvoice {
              billingId
              status
              createdAt
              dueDate
              updatedAt
              errorMessage
              requiresAction
              paymentSecret
              paymentUrl
              pdfUrl
              billingReason
              currency
              subTotal
              subTotalExcludingTax
              total
              totalExcludingTax
              tax
              amountDue
              attemptCount
            }

            fragment SubscriptionScheduledUpdateData on SubscriptionScheduledUpdate {
              subscriptionScheduleType
              scheduleStatus
              scheduledExecutionTime
              targetPackage {
                id
                refId
                displayName
              }
              scheduleVariables {
                ...ScheduleVariablesFragment
              }
            }

            fragment SubscriptionTrialConfigurationFragment on TrialConfiguration {
              trialEndBehavior
            }

            fragment TotalPriceFragment on CustomerSubscriptionTotalPrice {
              subTotal {
                amount
                currency
              }
              total {
                amount
                currency
              }
            }

            fragment TypographyConfigurationFragment on TypographyConfiguration {
              fontFamily
              h1 {
                ...FontVariantFragment
              }
              h2 {
                ...FontVariantFragment
              }
              h3 {
                ...FontVariantFragment
              }
              body {
                ...FontVariantFragment
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query, operation_name="GetPaywall", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return GetPaywall.model_validate(data)

    def get_entitlements(
        self, input: FetchEntitlementsQuery, **kwargs: Any
    ) -> GetEntitlements:
        _query = gql(
            """
            query GetEntitlements($query: FetchEntitlementsQuery!) {
              entitlements: cachedEntitlements(query: $query) {
                ...EntitlementFragment
              }
            }

            fragment EntitlementFragment on Entitlement {
              __typename
              isGranted
              accessDeniedReason
              customerId
              resourceId
              usageLimit
              hasUnlimitedUsage
              hasSoftLimit
              currentUsage
              requestedUsage
              requestedValues
              enumValues
              entitlementUpdatedAt
              usageUpdatedAt
              usagePeriodAnchor
              usagePeriodStart
              usagePeriodEnd
              nextResetDate
              resetPeriod
              resetPeriodConfiguration {
                ...ResetPeriodConfigurationFragment
              }
              feature {
                ...FeatureFragment
              }
            }

            fragment FeatureFragment on EntitlementFeature {
              __typename
              featureType
              meterType
              featureUnits
              featureUnitsPlural
              description
              displayName
              refId
              unitTransformation {
                divide
                round
              }
            }

            fragment ResetPeriodConfigurationFragment on ResetPeriodConfiguration {
              __typename
              ... on YearlyResetPeriodConfig {
                yearlyAccordingTo
              }
              ... on MonthlyResetPeriodConfig {
                monthlyAccordingTo
              }
              ... on WeeklyResetPeriodConfig {
                weeklyAccordingTo
              }
            }
            """
        )
        variables: Dict[str, object] = {"query": input}
        response = self.execute(
            query=_query,
            operation_name="GetEntitlements",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetEntitlements.model_validate(data)

    def get_entitlement(
        self, input: FetchEntitlementQuery, **kwargs: Any
    ) -> GetEntitlement:
        _query = gql(
            """
            query GetEntitlement($query: FetchEntitlementQuery!) {
              entitlement(query: $query) {
                ...EntitlementFragment
              }
            }

            fragment EntitlementFragment on Entitlement {
              __typename
              isGranted
              accessDeniedReason
              customerId
              resourceId
              usageLimit
              hasUnlimitedUsage
              hasSoftLimit
              currentUsage
              requestedUsage
              requestedValues
              enumValues
              entitlementUpdatedAt
              usageUpdatedAt
              usagePeriodAnchor
              usagePeriodStart
              usagePeriodEnd
              nextResetDate
              resetPeriod
              resetPeriodConfiguration {
                ...ResetPeriodConfigurationFragment
              }
              feature {
                ...FeatureFragment
              }
            }

            fragment FeatureFragment on EntitlementFeature {
              __typename
              featureType
              meterType
              featureUnits
              featureUnitsPlural
              description
              displayName
              refId
              unitTransformation {
                divide
                round
              }
            }

            fragment ResetPeriodConfigurationFragment on ResetPeriodConfiguration {
              __typename
              ... on YearlyResetPeriodConfig {
                yearlyAccordingTo
              }
              ... on MonthlyResetPeriodConfig {
                monthlyAccordingTo
              }
              ... on WeeklyResetPeriodConfig {
                weeklyAccordingTo
              }
            }
            """
        )
        variables: Dict[str, object] = {"query": input}
        response = self.execute(
            query=_query, operation_name="GetEntitlement", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return GetEntitlement.model_validate(data)

    def get_products(self, **kwargs: Any) -> GetProducts:
        query = gql(
            """
            query GetProducts {
              products(paging: {first: 20}) {
                edges {
                  node {
                    ...ProductFragment
                  }
                }
              }
            }

            fragment ProductFragment on Product {
              refId
              displayName
              description
              additionalMetaData
              productSettings {
                downgradePlan {
                  refId
                  displayName
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {}
        response = self.execute(
            query=query, operation_name="GetProducts", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return GetProducts.model_validate(data)

    def get_sdk_configuration(self, **kwargs: Any) -> GetSdkConfiguration:
        query = gql(
            """
            query GetSdkConfiguration {
              sdkConfiguration {
                sentryDsn
                isWidgetWatermarkEnabled
              }
            }
            """
        )
        variables: Dict[str, object] = {}
        response = self.execute(
            query=query,
            operation_name="GetSdkConfiguration",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetSdkConfiguration.model_validate(data)

    def get_customer_portal_by_ref_id(
        self, input: CustomerPortalInput, **kwargs: Any
    ) -> GetCustomerPortalByRefId:
        query = gql(
            """
            query GetCustomerPortalByRefId($input: CustomerPortalInput!) {
              customerPortal(input: $input) {
                ...CustomerPortalFragment
              }
            }

            fragment CustomerPortalBillingInformationFragment on CustomerPortalBillingInformation {
              email
              name
              defaultPaymentMethodLast4Digits
              defaultPaymentMethodId
              defaultPaymentExpirationMonth
              defaultPaymentExpirationYear
              defaultPaymentMethodType
            }

            fragment CustomerPortalConfigurationFragment on CustomerPortalConfiguration {
              palette {
                primary
                textColor
                backgroundColor
                borderColor
                currentPlanBackground
                iconsColor
                paywallBackgroundColor
              }
              typography {
                ...TypographyConfigurationFragment
              }
              customCss
            }

            fragment CustomerPortalEntitlementFragment on Entitlement {
              isGranted
              usageLimit
              currentUsage
              hasUnlimitedUsage
              hasSoftLimit
              usagePeriodStart
              usagePeriodEnd
              nextResetDate
              resetPeriod
              resetPeriodConfiguration {
                ...ResetPeriodConfigurationFragment
              }
              feature {
                ...FeatureFragment
              }
            }

            fragment CustomerPortalFragment on CustomerPortal {
              subscriptions {
                ...CustomerPortalSubscriptionFragment
              }
              entitlements {
                ...CustomerPortalEntitlementFragment
              }
              promotionalEntitlements {
                ...CustomerPortalPromotionalEntitlementFragment
              }
              billingInformation {
                ...CustomerPortalBillingInformationFragment
              }
              showWatermark
              billingPortalUrl
              canUpgradeSubscription
              configuration {
                ...CustomerPortalConfigurationFragment
              }
              resource {
                ...CustomerResourceFragment
              }
            }

            fragment CustomerPortalPromotionalEntitlementFragment on CustomerPortalPromotionalEntitlement {
              displayName
              hasUnlimitedUsage
              hasSoftLimit
              usageLimit
              period
              startDate
              endDate
            }

            fragment CustomerPortalSubscriptionAddonFragment on CustomerPortalAddon {
              addonId
              description
              displayName
              quantity
            }

            fragment CustomerPortalSubscriptionFragment on CustomerPortalSubscription {
              subscriptionId
              planId
              planName
              pricingType
              prices {
                ...CustomerPortalSubscriptionPriceFragment
              }
              pricing {
                unitQuantity
                billingPeriod
                billingModel
                pricingType
                usageBasedEstimatedBill
                price {
                  amount
                  currency
                }
                creditRate {
                  amount
                  customCurrencyId
                }
                feature {
                  featureUnits
                  featureUnitsPlural
                  displayName
                }
              }
              status
              trialRemainingDays
              billingPeriodRange {
                start
                end
              }
              totalPrice {
                subTotal {
                  amount
                  currency
                }
                total {
                  amount
                  currency
                }
                addonsTotal {
                  amount
                  currency
                }
              }
              addons {
                ...CustomerPortalSubscriptionAddonFragment
              }
              scheduledUpdates {
                ...CustomerPortalSubscriptionScheduledUpdateDataFragment
              }
            }

            fragment CustomerPortalSubscriptionPriceFragment on CustomerPortalSubscriptionPrice {
              billingPeriod
              billingModel
              blockSize
              price {
                amount
                currency
              }
              creditRate {
                amount
                customCurrencyId
              }
              feature {
                id
                refId
                displayName
                featureUnits
                featureUnitsPlural
              }
            }

            fragment CustomerPortalSubscriptionScheduledUpdateDataFragment on SubscriptionScheduledUpdate {
              subscriptionScheduleType
              scheduleStatus
              scheduledExecutionTime
              targetPackage {
                id
                refId
                displayName
                pricingType
              }
              scheduleVariables {
                ...ScheduleVariablesFragment
              }
            }

            fragment CustomerResourceFragment on CustomerResource {
              resourceId
            }

            fragment FeatureFragment on EntitlementFeature {
              __typename
              featureType
              meterType
              featureUnits
              featureUnitsPlural
              description
              displayName
              refId
              unitTransformation {
                divide
                round
              }
            }

            fragment FontVariantFragment on FontVariant {
              fontSize
              fontWeight
            }

            fragment ResetPeriodConfigurationFragment on ResetPeriodConfiguration {
              __typename
              ... on YearlyResetPeriodConfig {
                yearlyAccordingTo
              }
              ... on MonthlyResetPeriodConfig {
                monthlyAccordingTo
              }
              ... on WeeklyResetPeriodConfig {
                weeklyAccordingTo
              }
            }

            fragment ScheduleVariablesFragment on ScheduleVariables {
              __typename
              ... on PlanChangeVariables {
                planRefId
                changeType
                billingPeriod
                billableFeatures {
                  featureId
                  quantity
                }
                addons {
                  addonRefId
                  quantity
                }
                priceOverrides {
                  planRefId
                  addonRefId
                  featureId
                }
              }
              ... on DowngradeChangeVariables {
                downgradePlanRefId
                billingPeriod
                billableFeatures {
                  featureId
                  quantity
                }
                addons {
                  addonRefId
                  quantity
                }
                priceOverrides {
                  planRefId
                  addonRefId
                  featureId
                }
              }
              ... on BillingPeriodChangeVariables {
                billingPeriod
              }
              ... on UnitAmountChangeVariables {
                newUnitAmount
                featureId
              }
              ... on AddonChangeVariables {
                addonRefId
                newQuantity
              }
              ... on PlanPriceOverrideChangeVariables {
                planRefId
                featureId
              }
              ... on AddonPriceOverrideChangeVariables {
                addonRefId
                featureId
              }
            }

            fragment TypographyConfigurationFragment on TypographyConfiguration {
              fontFamily
              h1 {
                ...FontVariantFragment
              }
              h2 {
                ...FontVariantFragment
              }
              h3 {
                ...FontVariantFragment
              }
              body {
                ...FontVariantFragment
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="GetCustomerPortalByRefId",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetCustomerPortalByRefId.model_validate(data)

    def get_checkout_state(
        self, input: CheckoutStateInput, **kwargs: Any
    ) -> GetCheckoutState:
        query = gql(
            """
            query GetCheckoutState($input: CheckoutStateInput!) {
              checkoutState(input: $input) {
                ...CheckoutStateFragment
              }
            }

            fragment AddonDependencyFragment on Addon {
              id
              refId
              displayName
              description
            }

            fragment AddonFragment on Addon {
              id
              refId
              billingId
              displayName
              description
              additionalMetaData
              hiddenFromWidgets
              entitlements {
                ...PackageEntitlementFragment
              }
              prices {
                ...PriceFragment
              }
              overagePrices {
                ...OveragePriceFragment
              }
              pricingType
              maxQuantity
              dependencies {
                ...AddonDependencyFragment
              }
            }

            fragment CheckoutConfigurationFragment on CheckoutConfiguration {
              palette {
                primary
                textColor
                backgroundColor
                borderColor
                summaryBackgroundColor
                __typename
              }
              typography {
                ...TypographyConfigurationFragment
                __typename
              }
              customCss
              content {
                collectPhoneNumber
              }
              __typename
            }

            fragment CheckoutStateFragment on CheckoutState {
              configuration {
                ...CheckoutConfigurationFragment
              }
              setupSecret
              customer {
                ...CustomerFragment
              }
              activeSubscription {
                ...SubscriptionFragment
              }
              resource {
                ...CustomerResourceFragment
              }
              plan {
                ...PlanFragment
              }
              billingIntegration {
                billingIdentifier
                credentials {
                  accountId
                  publicKey
                }
              }
            }

            fragment CouponFragment on Coupon {
              id
              discountValue
              percentOff
              amountsOff {
                amount
                currency
              }
              type
              additionalMetaData
              refId
              name
              description
              createdAt
              updatedAt
              billingId
              billingLinkUrl
              status
              syncStates {
                vendorIdentifier
                status
              }
            }

            fragment CustomerFragment on Customer {
              ...SlimCustomerFragment
              hasPaymentMethod
              hasActiveSubscription
              defaultPaymentExpirationMonth
              defaultPaymentExpirationYear
              defaultPaymentMethodLast4Digits
              defaultPaymentMethodType
              trialedPlans {
                productId
                productRefId
                planRefId
                planId
              }
              experimentInfo {
                groupType
                groupName
                id
                name
              }
              coupon {
                ...CouponFragment
              }
              eligibleForTrial {
                productId
                productRefId
                eligible
              }
              promotionalEntitlements {
                ...PromotionalEntitlementFragment
              }
            }

            fragment CustomerResourceFragment on CustomerResource {
              resourceId
            }

            fragment FontVariantFragment on FontVariant {
              fontSize
              fontWeight
            }

            fragment OveragePriceFragment on Price {
              billingModel
              billingPeriod
              billingId
              billingCountryCode
              price {
                amount
                currency
              }
              tiersMode
              tiers {
                ...PriceTierFragment
              }
              feature {
                refId
                featureUnits
                featureUnitsPlural
                displayName
                description
              }
            }

            fragment PackageEntitlementFragment on PackageEntitlement {
              usageLimit
              hasUnlimitedUsage
              hasSoftLimit
              featureId
              resetPeriod
              hiddenFromWidgets
              isCustom
              displayNameOverride
              enumValues
              feature {
                featureType
                meterType
                featureUnits
                featureUnitsPlural
                displayName
                description
                refId
                additionalMetaData
              }
            }

            fragment PlanCompatiblePackageGroupsFragment on PlanCompatiblePackageGroups {
              packageGroupId
              displayName
              addons {
                ...AddonFragment
              }
              options {
                minItems
                freeItems
              }
            }

            fragment PlanFragment on Plan {
              id
              refId
              displayName
              description
              billingId
              versionNumber
              additionalMetaData
              hiddenFromWidgets
              product {
                ...ProductFragment
              }
              basePlan {
                refId
                displayName
              }
              entitlements {
                ...PackageEntitlementFragment
              }
              inheritedEntitlements {
                ...PackageEntitlementFragment
              }
              compatibleAddons {
                ...AddonFragment
              }
              compatiblePackageGroups {
                ...PlanCompatiblePackageGroupsFragment
              }
              prices {
                ...PriceFragment
              }
              overagePrices {
                ...OveragePriceFragment
              }
              pricingType
              defaultTrialConfig {
                duration
                units
                budget {
                  limit
                }
                trialEndBehavior
              }
            }

            fragment PriceFragment on Price {
              billingModel
              billingPeriod
              billingCadence
              billingId
              minUnitQuantity
              maxUnitQuantity
              billingCountryCode
              price {
                amount
                currency
              }
              creditRate {
                amount
                customCurrencyId
              }
              tiersMode
              tiers {
                ...PriceTierFragment
              }
              feature {
                refId
                featureUnits
                featureUnitsPlural
                displayName
                description
              }
              blockSize
            }

            fragment PriceTierFragment on PriceTier {
              upTo
              unitPrice {
                amount
                currency
              }
              flatPrice {
                amount
                currency
              }
            }

            fragment ProductFragment on Product {
              refId
              displayName
              description
              additionalMetaData
              productSettings {
                downgradePlan {
                  refId
                  displayName
                }
              }
            }

            fragment PromotionalEntitlementFragment on PromotionalEntitlement {
              status
              usageLimit
              featureId
              hasUnlimitedUsage
              hasSoftLimit
              resetPeriod
              endDate
              isVisible
              feature {
                featureType
                meterType
                featureUnits
                featureUnitsPlural
                displayName
                description
                refId
                additionalMetaData
              }
            }

            fragment ScheduleVariablesFragment on ScheduleVariables {
              __typename
              ... on PlanChangeVariables {
                planRefId
                changeType
                billingPeriod
                billableFeatures {
                  featureId
                  quantity
                }
                addons {
                  addonRefId
                  quantity
                }
                priceOverrides {
                  planRefId
                  addonRefId
                  featureId
                }
              }
              ... on DowngradeChangeVariables {
                downgradePlanRefId
                billingPeriod
                billableFeatures {
                  featureId
                  quantity
                }
                addons {
                  addonRefId
                  quantity
                }
                priceOverrides {
                  planRefId
                  addonRefId
                  featureId
                }
              }
              ... on BillingPeriodChangeVariables {
                billingPeriod
              }
              ... on UnitAmountChangeVariables {
                newUnitAmount
                featureId
              }
              ... on AddonChangeVariables {
                addonRefId
                newQuantity
              }
              ... on PlanPriceOverrideChangeVariables {
                planRefId
                featureId
              }
              ... on AddonPriceOverrideChangeVariables {
                addonRefId
                featureId
              }
            }

            fragment SlimCustomerFragment on Customer {
              id
              name
              email
              createdAt
              updatedAt
              refId
              customerId
              billingId
              additionalMetaData
              awsMarketplaceCustomerId
            }

            fragment SubscriptionFragment on CustomerSubscription {
              id
              subscriptionId
              payingCustomer {
                ...SlimCustomerFragment
              }
              startDate
              endDate
              trialEndDate
              cancellationDate
              effectiveEndDate
              status
              refId
              currentBillingPeriodEnd
              additionalMetaData
              billingId
              billingLinkUrl
              latestInvoice {
                ...SubscriptionInvoiceFragment
              }
              paymentCollection
              paymentCollectionMethod
              billingSyncError
              resource {
                ...CustomerResourceFragment
              }
              experimentInfo {
                name
                groupType
                groupName
                id
              }
              prices {
                usageLimit
                price {
                  ...PriceFragment
                }
              }
              totalPrice {
                ...TotalPriceFragment
              }
              pricingType
              plan {
                ...PlanFragment
              }
              addons {
                id
                quantity
                addon {
                  ...AddonFragment
                }
              }
              scheduledUpdates {
                ...SubscriptionScheduledUpdateData
              }
              futureUpdates {
                ...SubscriptionFutureUpdateData
              }
              trialConfiguration {
                ...SubscriptionTrialConfigurationFragment
              }
            }

            fragment SubscriptionFutureUpdateData on SubscriptionFutureUpdate {
              subscriptionScheduleType
              scheduleStatus
              scheduledExecutionTime
              targetPackage {
                id
                refId
                displayName
              }
              scheduleVariables {
                ...ScheduleVariablesFragment
              }
            }

            fragment SubscriptionInvoiceFragment on SubscriptionInvoice {
              billingId
              status
              createdAt
              dueDate
              updatedAt
              errorMessage
              requiresAction
              paymentSecret
              paymentUrl
              pdfUrl
              billingReason
              currency
              subTotal
              subTotalExcludingTax
              total
              totalExcludingTax
              tax
              amountDue
              attemptCount
            }

            fragment SubscriptionScheduledUpdateData on SubscriptionScheduledUpdate {
              subscriptionScheduleType
              scheduleStatus
              scheduledExecutionTime
              targetPackage {
                id
                refId
                displayName
              }
              scheduleVariables {
                ...ScheduleVariablesFragment
              }
            }

            fragment SubscriptionTrialConfigurationFragment on TrialConfiguration {
              trialEndBehavior
            }

            fragment TotalPriceFragment on CustomerSubscriptionTotalPrice {
              subTotal {
                amount
                currency
              }
              total {
                amount
                currency
              }
            }

            fragment TypographyConfigurationFragment on TypographyConfiguration {
              fontFamily
              h1 {
                ...FontVariantFragment
              }
              h2 {
                ...FontVariantFragment
              }
              h3 {
                ...FontVariantFragment
              }
              body {
                ...FontVariantFragment
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="GetCheckoutState",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetCheckoutState.model_validate(data)

    def get_mock_paywall(self, input: GetPaywallInput, **kwargs: Any) -> GetMockPaywall:
        query = gql(
            """
            query GetMockPaywall($input: GetPaywallInput!) {
              mockPaywall(input: $input) {
                plans {
                  ...MockPaywallPlanFragment
                }
                configuration {
                  ...PaywallConfigurationFragment
                }
              }
            }

            fragment FontVariantFragment on FontVariant {
              fontSize
              fontWeight
            }

            fragment LayoutConfigurationFragment on PaywallLayoutConfiguration {
              alignment
              planWidth
              planMargin
              planPadding
            }

            fragment MockPaywallAddonDependencyFragment on PaywallAddon {
              refId
              displayName
              description
            }

            fragment MockPaywallAddonFragment on PaywallAddon {
              refId
              displayName
              description
              additionalMetaData
              billingId
              maxQuantity
              hiddenFromWidgets
              dependencies {
                ...MockPaywallAddonDependencyFragment
              }
              entitlements {
                ...MockPaywallPackageEntitlementFragment
              }
              prices {
                ...MockPaywallPriceFragment
              }
              pricingType
            }

            fragment MockPaywallPackageEntitlementFragment on Entitlement {
              usageLimit
              hasUnlimitedUsage
              hasSoftLimit
              resetPeriod
              hiddenFromWidgets
              displayNameOverride
              enumValues
              feature {
                featureType
                meterType
                featureUnits
                featureUnitsPlural
                displayName
                description
                refId
                additionalMetaData
              }
            }

            fragment MockPaywallPlanCompatiblePackageGroupsFragment on PaywallPlanCompatiblePackageGroup {
              packageGroupId
              displayName
              description
              addons {
                ...MockPaywallAddonFragment
              }
              options {
                minItems
                freeItems
              }
            }

            fragment MockPaywallPlanFragment on PaywallPlan {
              refId
              description
              displayName
              billingId
              additionalMetaData
              product {
                refId
                displayName
                description
                additionalMetaData
              }
              basePlan {
                refId
                displayName
              }
              entitlements {
                ...MockPaywallPackageEntitlementFragment
              }
              inheritedEntitlements {
                ...MockPaywallPackageEntitlementFragment
              }
              prices {
                ...MockPaywallPriceFragment
              }
              pricingType
              defaultTrialConfig {
                duration
                units
                budget {
                  limit
                }
                trialEndBehavior
              }
              compatibleAddons {
                ...MockPaywallAddonFragment
              }
              compatiblePackageGroups {
                ...MockPaywallPlanCompatiblePackageGroupsFragment
              }
            }

            fragment MockPaywallPriceFragment on PaywallPrice {
              billingModel
              billingPeriod
              billingId
              minUnitQuantity
              maxUnitQuantity
              billingCountryCode
              price {
                amount
                currency
              }
              creditRate {
                amount
                customCurrencyId
              }
              tiersMode
              tiers {
                ...PriceTierFragment
              }
              feature {
                refId
                featureUnits
                featureUnitsPlural
                displayName
              }
              blockSize
            }

            fragment PaywallConfigurationFragment on PaywallConfiguration {
              palette {
                primary
                textColor
                backgroundColor
                borderColor
                currentPlanBackground
              }
              typography {
                ...TypographyConfigurationFragment
              }
              layout {
                ...LayoutConfigurationFragment
              }
              customCss
            }

            fragment PriceTierFragment on PriceTier {
              upTo
              unitPrice {
                amount
                currency
              }
              flatPrice {
                amount
                currency
              }
            }

            fragment TypographyConfigurationFragment on TypographyConfiguration {
              fontFamily
              h1 {
                ...FontVariantFragment
              }
              h2 {
                ...FontVariantFragment
              }
              h3 {
                ...FontVariantFragment
              }
              body {
                ...FontVariantFragment
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query, operation_name="GetMockPaywall", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return GetMockPaywall.model_validate(data)

    def get_usage_history(
        self, usage_history_input: UsageHistoryInput, **kwargs: Any
    ) -> GetUsageHistory:
        query = gql(
            """
            query GetUsageHistory($usageHistoryInput: UsageHistoryInput!) {
              usageHistory(usageHistoryInput: $usageHistoryInput) {
                ...UsageHistoryFragment
              }
            }

            fragment UsageHistoryFragment on UsageHistory {
              startDate
              endDate
              markers {
                type
                timestamp
              }
              usageMeasurements {
                date
                value
                isResetPoint
              }
              groups {
                groupInfo {
                  key
                  value
                }
                usageMeasurements {
                  date
                  value
                  isResetPoint
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"usageHistoryInput": usage_history_input}
        response = self.execute(
            query=query, operation_name="GetUsageHistory", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return GetUsageHistory.model_validate(data)

    def get_usage_history_v_2(
        self, input: UsageHistoryV2Input, **kwargs: Any
    ) -> GetUsageHistoryV2:
        query = gql(
            """
            query GetUsageHistoryV2($input: UsageHistoryV2Input!) {
              usageHistoryV2(input: $input) {
                ...UsageHistoryV2Fragment
              }
            }

            fragment UsageHistoryV2Fragment on UsageHistoryV2 {
              markers {
                type
                timestamp
              }
              series {
                tags {
                  key
                  value
                }
                points {
                  timestamp
                  value
                  isResetPoint
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = self.execute(
            query=query,
            operation_name="GetUsageHistoryV2",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetUsageHistoryV2.model_validate(data)
